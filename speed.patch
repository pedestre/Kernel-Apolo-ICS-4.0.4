diff -rupN kernel-s2-ics-update7/arch/arm/configs/u1_speedmod_defconfig kernel/arch/arm/configs/u1_speedmod_defconfig
--- kernel-s2-ics-update7/arch/arm/configs/u1_speedmod_defconfig	1970-01-01 07:30:00.000000000 +0730
+++ kernel/arch/arm/configs/u1_speedmod_defconfig	2012-07-28 13:18:12.000000000 +0800
@@ -0,0 +1,2999 @@
+#
+# Automatically generated make config: don't edit
+# Linux/arm 3.0.15 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_HAVE_PWM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_NO_IOPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_LOCKBREAK=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE="/home/mrd/Descargas/Undervolting/package/ggcc-linaro-arm-linux-gnueabihf-2012.06-20120625_linux/bin/arm-linux-gnueabihf-"
+CONFIG_LOCALVERSION="-Apolo3-27ExtremeV2"
+#CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_CHIP=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_CGROUP_FREEZER=y
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CPUSETS is not set
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_CGROUP_MEM_RES_CTLR is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_BLK_CGROUP is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="/tmp/initramfs-source"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_INITRAMFS_COMPRESSION_NONE is not set
+CONFIG_INITRAMFS_COMPRESSION_GZIP=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+# CONFIG_CC_CHECK_WARNING_STRICTLY is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=1
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_HOTPLUG=y
+# CONFIG_PRINTK is not set
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_ASHMEM=y
+# CONFIG_AIO is not set
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_IOSCHED_VR=y
+CONFIG_IOSCHED_SIO=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+CONFIG_ARCH_EXYNOS=y
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_TCC_926 is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+CONFIG_PLAT_SAMSUNG=y
+
+#
+# Base Address for SFR mapping
+#
+CONFIG_S3C_ADDR_BASE=0xFB000000
+
+#
+# Boot options
+#
+# CONFIG_S3C_BOOT_ERROR_RESET is not set
+CONFIG_S3C_BOOT_UART_FORCE_FIFO=y
+CONFIG_S3C_LOWLEVEL_UART_PORT=2
+CONFIG_SAMSUNG_CLKSRC=y
+CONFIG_SAMSUNG_IRQ_VIC_TIMER=y
+CONFIG_SAMSUNG_IRQ_UART=y
+CONFIG_SAMSUNG_GPIOLIB_4BIT=y
+CONFIG_S3C_GPIO_CFG_S3C24XX=y
+CONFIG_S3C_GPIO_CFG_S3C64XX=y
+CONFIG_S3C_GPIO_PULL_UPDOWN=y
+CONFIG_S5P_GPIO_DRVSTR=y
+CONFIG_SAMSUNG_GPIO_EXTRA=0
+CONFIG_S3C_GPIO_SPACE=0
+CONFIG_S3C_GPIO_TRACK=y
+CONFIG_S3C_ADC=y
+CONFIG_S3C_DEV_ADC=y
+# CONFIG_S3C_DEV_ADC1 is not set
+CONFIG_S3C_DEV_HSMMC2=y
+CONFIG_S3C_DEV_HSMMC3=y
+CONFIG_EXYNOS4_DEV_MSHC=y
+CONFIG_S3C_DEV_I2C1=y
+CONFIG_S3C_DEV_I2C3=y
+CONFIG_S3C_DEV_I2C5=y
+CONFIG_S3C_DEV_I2C6=y
+CONFIG_S3C_DEV_I2C7=y
+CONFIG_S3C_DEV_I2C8_EMUL=y
+CONFIG_S3C_DEV_I2C9_EMUL=y
+CONFIG_S3C_DEV_I2C11_EMUL=y
+CONFIG_S3C_DEV_I2C14_EMUL=y
+CONFIG_S3C_DEV_I2C16_EMUL=y
+CONFIG_S3C_DEV_WDT=y
+CONFIG_S3C_DEV_RTC=y
+CONFIG_SAMSUNG_DEV_ADC=y
+CONFIG_SAMSUNG_DEV_TS=y
+CONFIG_SAMSUNG_DEV_TS1=y
+CONFIG_S3C24XX_PWM=y
+CONFIG_S3C_PL330_DMA=y
+# CONFIG_DMA_M2M_TEST is not set
+
+#
+# Power management
+#
+# CONFIG_SAMSUNG_PM_DEBUG is not set
+# CONFIG_SAMSUNG_PM_CHECK is not set
+
+#
+# Power Domain
+#
+CONFIG_SAMSUNG_PD=y
+CONFIG_PLAT_S5P=y
+CONFIG_S5P_GPIO_INT=y
+CONFIG_S5P_SYSTEM_MMU=y
+# CONFIG_S5P_SYSTEM_MMU_REFCOUNT is not set
+# CONFIG_S5P_SYSTEM_MMU_DEBUG is not set
+CONFIG_IOVMM=y
+CONFIG_IOMMU_EXYNOS4_API=y
+CONFIG_S3C_DEV_FIMC=y
+CONFIG_S5P_DEV_MFC=y
+CONFIG_S5P_DEV_FIMD0=y
+CONFIG_S5P_DEV_TVOUT=y
+CONFIG_S5P_DEV_FIMG2D=y
+CONFIG_S5P_DEV_CSIS=y
+CONFIG_S5P_DEV_JPEG=y
+CONFIG_S5P_DEV_USB_EHCI=y
+CONFIG_S5P_DEV_FIMD_S5P=y
+CONFIG_S5P_DEV_USBGADGET=y
+CONFIG_S5P_MEM_CMA=y
+# CONFIG_S5P_BTS is not set
+# CONFIG_S3C_DEV_TSI is not set
+CONFIG_ARCH_EXYNOS4=y
+# CONFIG_ARCH_EXYNOS5 is not set
+CONFIG_CPU_EXYNOS4210=y
+# CONFIG_S5PV310_HI_ARMCLK_THAN_1_2GHZ is not set
+CONFIG_EXYNOS4_PM=y
+CONFIG_EXYNOS4_CPUIDLE=y
+CONFIG_EXYNOS4_LOWPWR_IDLE=y
+CONFIG_EXYNOS_MCT=y
+CONFIG_EXYNOS4_SETUP_FIMD0=y
+CONFIG_EXYNOS_DEV_PD=y
+CONFIG_EXYNOS4_SETUP_I2C1=y
+CONFIG_EXYNOS4_SETUP_I2C3=y
+CONFIG_EXYNOS4_SETUP_I2C5=y
+CONFIG_EXYNOS4_SETUP_I2C6=y
+CONFIG_EXYNOS4_SETUP_I2C7=y
+CONFIG_EXYNOS4_SETUP_MFC=y
+CONFIG_EXYNOS4_SETUP_SDHCI=y
+CONFIG_EXYNOS4_SETUP_SDHCI_GPIO=y
+CONFIG_EXYNOS4_SETUP_MSHCI=y
+CONFIG_EXYNOS4_SETUP_MSHCI_GPIO=y
+CONFIG_EXYNOS4_SETUP_FIMC0=y
+CONFIG_EXYNOS4_SETUP_FIMC1=y
+CONFIG_EXYNOS4_SETUP_FIMC2=y
+CONFIG_EXYNOS4_SETUP_FIMC3=y
+CONFIG_EXYNOS4_SETUP_USB_PHY=y
+CONFIG_EXYNOS4_SETUP_CSIS=y
+CONFIG_EXYNOS4_SETUP_FB_S5P=y
+CONFIG_EXYNOS4_SETUP_TVOUT=y
+CONFIG_EXYNOS4_SETUP_THERMAL=y
+# CONFIG_EXYNOS_SETUP_THERMAL is not set
+# CONFIG_EXYNOS4_ENABLE_CLOCK_DOWN is not set
+CONFIG_EXYNOS4_CPUFREQ=y
+# CONFIG_EXYNOS4210_1200MHZ_SUPPORT is not set
+CONFIG_EXYNOS4210_1400MHZ_SUPPORT=y
+
+#
+# Support dynamic CPU Hotplug
+#
+CONFIG_EXYNOS_PM_HOTPLUG=y
+# CONFIG_STAND_ALONE_POLICY is not set
+# CONFIG_LEGACY_HOTPLUG_POLICY is not set
+CONFIG_WITH_DVFS_POLICY=y
+# CONFIG_DVFS_NR_RUNNING_POLICY is not set
+# CONFIG_NR_RUNNING_POLICY is not set
+
+#
+# Busfreq Model
+#
+CONFIG_BUSFREQ=y
+# CONFIG_BUSFREQ_QOS is not set
+# CONFIG_BUSFREQ_OPP is not set
+# CONFIG_DEVFREQ_BUS is not set
+# CONFIG_BUSFREQ_DEBUG is not set
+# CONFIG_BUSFREQ_L2_160M is not set
+CONFIG_SEC_THERMISTOR=y
+# CONFIG_EXYNOS_SYSREG_PM is not set
+# CONFIG_ANDROID_WIP is not set
+
+#
+# EXYNOS4 Machines
+#
+# CONFIG_MACH_SMDKC210 is not set
+# CONFIG_MACH_SMDKV310 is not set
+# CONFIG_MACH_ARMLEX4210 is not set
+# CONFIG_MACH_UNIVERSAL_C210 is not set
+# CONFIG_MACH_NURI is not set
+CONFIG_MACH_U1=y
+CONFIG_MACH_U1_BD=y
+# CONFIG_MACH_U1CAMERA_BD is not set
+# CONFIG_MACH_Q1_BD is not set
+# CONFIG_MACH_PX is not set
+CONFIG_PANEL_U1=y
+CONFIG_TARGET_LOCALE_EUR=y
+# CONFIG_TARGET_LOCALE_LTN is not set
+# CONFIG_TARGET_LOCALE_KOR is not set
+# CONFIG_TARGET_LOCALE_NAATT_TEMP is not set
+# CONFIG_TARGET_LOCALE_P2EUR_TEMP is not set
+# CONFIG_TARGET_LOCALE_P2TMO_TEMP is not set
+# CONFIG_TARGET_LOCALE_EUR_U1_NFC is not set
+# CONFIG_TARGET_LOCALE_NTT is not set
+# CONFIG_TARGET_LOCALE_CHN is not set
+# CONFIG_TARGET_LOCALE_USA is not set
+# CONFIG_MACH_SMDK4X12 is not set
+# CONFIG_MACH_MIDAS is not set
+# CONFIG_MIDAS_COMMON_BD is not set
+# CONFIG_P4NOTE_00_BD is not set
+# CONFIG_GC1_00_BD is not set
+# CONFIG_T0_00_BD is not set
+# CONFIG_IRON_BD is not set
+# CONFIG_GRANDE_BD is not set
+# CONFIG_SLP is not set
+# CONFIG_MACH_REDWOOD is not set
+# CONFIG_GPS_BCM47511 is not set
+# CONFIG_GPS_GSD4T is not set
+# CONFIG_GPIO_NAPLES_00_BD is not set
+# CONFIG_EXYNOS4_DEV_TMU is not set
+# CONFIG_WRITEBACK_ENABLED is not set
+# CONFIG_EXYNOS5_DEV_BTS is not set
+
+#
+# MMC/SD slot setup
+#
+
+#
+# SELECT SYNOPSYS CONTROLLER INTERFACE DRIVER
+#
+# CONFIG_EXYNOS4_MSHC_MPLL_40MHZ is not set
+# CONFIG_EXYNOS4_MSHC_VPLL_46MHZ is not set
+CONFIG_EXYNOS4_MSHC_EPLL_45MHZ=y
+
+#
+# Use 8-bit bus width
+#
+CONFIG_EXYNOS4_MSHC_8BIT=y
+# CONFIG_EXYNOS4_SDHCI_CH2_8BIT is not set
+
+#
+# Use DDR
+#
+CONFIG_EXYNOS4_MSHC_DDR=y
+
+#
+# Miscellaneous drivers
+#
+# CONFIG_WAKEUP_ASSIST is not set
+
+#
+# Debugging Feature
+#
+# CONFIG_SEC_DEBUG is not set
+
+#
+# Samsung Modem Feature
+#
+# CONFIG_LTE_VIA_SWITCH is not set
+# CONFIG_SEC_MODEM_M0_C2C is not set
+# CONFIG_SEC_MODEM_M0 is not set
+# CONFIG_SEC_MODEM_M0_CTC is not set
+# CONFIG_SEC_MODEM_M0_GRANDECTC is not set
+# CONFIG_SEC_MODEM_M1 is not set
+# CONFIG_SEC_MODEM_C1 is not set
+# CONFIG_SEC_MODEM_C1_VZW is not set
+# CONFIG_SEC_MODEM_C1_LGT is not set
+# CONFIG_SEC_MODEM_M2 is not set
+CONFIG_SEC_MODEM_U1=y
+# CONFIG_SEC_MODEM_U1_LGT is not set
+# CONFIG_SEC_MODEM_GAIA is not set
+# CONFIG_SEC_MODEM_IRON is not set
+# CONFIG_SEC_MODEM_P8LTE is not set
+# CONFIG_BT_CSR8811 is not set
+CONFIG_BT_BCM4330=y
+# CONFIG_BT_BCM4334 is not set
+# CONFIG_BT_BCM43241 is not set
+CONFIG_BT_MGMT=y
+
+#
+# Qualcomm Modem Feature
+#
+# CONFIG_QC_MODEM is not set
+# CONFIG_MSM_SUBSYSTEM_RESTART is not set
+# CONFIG_QC_MODEM_MDM9X15 is not set
+# CONFIG_MDM_HSIC_PM is not set
+# CONFIG_SAMSUNG_PRODUCT_SHIP is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_TRUSTZONE is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_SWP_EMULATE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_OUTER_CACHE=y
+CONFIG_OUTER_CACHE_SYNC=y
+CONFIG_CACHE_L2X0=y
+CONFIG_CACHE_PL310=y
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_ARM_PLD_SIZE=32
+CONFIG_CPU_HAS_PMU=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_742230 is not set
+# CONFIG_ARM_ERRATA_742231 is not set
+# CONFIG_PL310_ERRATA_588369 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_ARM_ERRATA_720791 is not set
+CONFIG_PL310_ERRATA_727915=y
+CONFIG_ARM_ERRATA_743622=y
+CONFIG_ARM_ERRATA_751472=y
+CONFIG_ARM_ERRATA_753970=y
+CONFIG_ARM_ERRATA_754322=y
+# CONFIG_ARM_ERRATA_754327 is not set
+# CONFIG_ARM_ERRATA_761320 is not set
+# CONFIG_ARM_ERRATA_761171 is not set
+# CONFIG_ARM_ERRATA_762974 is not set
+# CONFIG_ARM_ERRATA_763722 is not set
+CONFIG_ARM_GIC=y
+CONFIG_PL330=y
+# CONFIG_FIQ_DEBUGGER is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+CONFIG_ARM_ERRATA_764369=y
+# CONFIG_PL310_ERRATA_769419 is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_SMT=y
+CONFIG_HAVE_ARM_SCU=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=2
+CONFIG_HOTPLUG_CPU=y
+CONFIG_LOCAL_TIMERS=y
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_HZ=200
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_ARCH_SKIP_SECONDARY_CALIBRATE=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_COMPACTION is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CLEANCACHE is not set
+CONFIG_CMA=y
+# CONFIG_CMA_DEVELOPEMENT is not set
+CONFIG_CMA_BEST_FIT=y
+CONFIG_FORCE_MAX_ZONEORDER=12
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+# CONFIG_ARM_FLUSH_CONSOLE_ON_RESTART is not set
+# CONFIG_VMWARE_MVP is not set
+
+#
+# Boot options
+#
+# CONFIG_USE_OF is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="console=ttySAC2,115200 consoleblank=0"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_LULZACTIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND_FLEXRATE=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_ADAPTIVE=y
+CONFIG_CPU_FREQ_GOV_PEGASUSQ=y
+CONFIG_CPU_FREQ_GOV_LULZACTIVE=y
+CONFIG_CPU_FREQ_GOV_SMARTASS2=y
+CONFIG_CPU_FREQ_GOV_HOTPLUG=y
+# CONFIG_CPU_FREQ_GOV_SLP is not set
+# CONFIG_CPU_FREQ_DVFS_MONITOR is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_WATCHDOG_TIMEOUT=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_WAKELOCK=y
+CONFIG_WAKELOCK_STAT=y
+CONFIG_USER_WAKELOCK=y
+CONFIG_EARLYSUSPEND=y
+# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
+# CONFIG_CONSOLE_EARLYSUSPEND is not set
+CONFIG_FB_EARLYSUSPEND=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_HAS_OPP=y
+CONFIG_PM_OPP=y
+CONFIG_PM_RUNTIME_CLK=y
+# CONFIG_SUSPEND_TIME is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+CONFIG_INET_ESP=y
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+# CONFIG_IPV6_ROUTE_INFO is not set
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_MROUTE is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+CONFIG_NET_ACTIVITY_STATS=y
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_BROADCAST=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+# CONFIG_NF_CONNTRACK_SNMP is not set
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_CONNMARK=y
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+# CONFIG_NETFILTER_XT_TARGET_CT is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+# CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_HL=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP_NF_TARGET_LOG=y
+# CONFIG_IP_NF_TARGET_ULOG is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_NF_NAT_PROTO_DCCP=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+CONFIG_NF_NAT_PROTO_SCTP=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+CONFIG_NF_NAT_SIP=y
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV6=y
+CONFIG_NF_CONNTRACK_IPV6=y
+# CONFIG_IP6_NF_QUEUE is not set
+CONFIG_IP6_NF_IPTABLES=y
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_TARGET_HL is not set
+CONFIG_IP6_NF_TARGET_LOG=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+CONFIG_PHONET=y
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+CONFIG_NET_SCH_HTB=y
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+CONFIG_NET_SCH_INGRESS=y
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+CONFIG_NET_CLS_U32=y
+# CONFIG_CLS_U32_PERF is not set
+# CONFIG_CLS_U32_MARK is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+CONFIG_NET_EMATCH_U32=y
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_NET_ACT_GACT=y
+# CONFIG_GACT_PROB is not set
+CONFIG_NET_ACT_MIRRED=y
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_CLS_IND is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+# CONFIG_DNS_RESOLVER is not set
+# CONFIG_BATMAN_ADV is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+# CONFIG_BT_BNEP_MC_FILTER is not set
+# CONFIG_BT_BNEP_PROTO_FILTER is not set
+CONFIG_BT_HIDP=y
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_BT_HCIBTUSB is not set
+# CONFIG_BT_HCIBTSDIO is not set
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+# CONFIG_BT_HCIUART_BCSP is not set
+# CONFIG_BT_HCIUART_ATH3K is not set
+# CONFIG_BT_HCIUART_LL is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+# CONFIG_CFG80211_ALLOW_RECONNECT is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_PM=y
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_RFKILL_REGULATOR is not set
+# CONFIG_RFKILL_GPIO is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_DMA_SHARED_BUFFER is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_AD525X_DPOT is not set
+CONFIG_ANDROID_PMEM=y
+
+#
+# Reserved memory configurations
+#
+CONFIG_ANDROID_PMEM_MEMSIZE_PMEM=4096
+CONFIG_ANDROID_PMEM_MEMSIZE_PMEM_GPU1=4
+CONFIG_ANDROID_PMEM_MEMSIZE_PMEM_CAM=0
+# CONFIG_INTEL_MID_PTI is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_SENSORS_AK8975 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+CONFIG_UID_STAT=y
+# CONFIG_BMP085 is not set
+# CONFIG_WL127X_RFKILL is not set
+# CONFIG_APANIC is not set
+# CONFIG_JACK_MON is not set
+# CONFIG_UART_SELECT is not set
+CONFIG_SEC_DEV_JACK=y
+# CONFIG_FM34_WE395 is not set
+# CONFIG_AUDIENCE_ES305 is not set
+# CONFIG_2MIC_FM34_WE395 is not set
+CONFIG_MUIC_MAX8997=y
+# CONFIG_MUIC_MAX8997_OVPUI is not set
+# CONFIG_USBHUB_USB3503 is not set
+CONFIG_PN544=y
+# CONFIG_STMPE811_ADC is not set
+# CONFIG_MPU_SENSORS_MPU3050 is not set
+# CONFIG_MPU_SENSORS_MPU6050 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IWMC3200TOP is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+CONFIG_SEC_MODEM=y
+CONFIG_UMTS_MODEM_XMM6260=y
+# CONFIG_UMTS_MODEM_XMM6262 is not set
+# CONFIG_CDMA_MODEM_CBP71 is not set
+# CONFIG_CDMA_MODEM_CBP72 is not set
+# CONFIG_LTE_MODEM_CMC221 is not set
+# CONFIG_CDMA_MODEM_MDM6600 is not set
+# CONFIG_GSM_MODEM_ESC6270 is not set
+# CONFIG_LINK_DEVICE_MIPI is not set
+# CONFIG_LINK_DEVICE_DPRAM is not set
+# CONFIG_LINK_DEVICE_USB is not set
+CONFIG_LINK_DEVICE_HSIC=y
+# CONFIG_LINK_DEVICE_C2C is not set
+# CONFIG_IPC_CMC22x_OLD_RFS is not set
+# CONFIG_SIPC_VER_5 is not set
+# CONFIG_SIM_DETECT is not set
+# CONFIG_LTE_MODEM_CMC220 is not set
+# CONFIG_INTERNAL_MODEM_IF is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=y
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+# CONFIG_IFB is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+# CONFIG_VETH is not set
+# CONFIG_MII is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+CONFIG_WLAN=y
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+CONFIG_WIFI_CONTROL_FUNC=y
+# CONFIG_ATH_COMMON is not set
+# CONFIG_BCM4334 is not set
+CONFIG_BCM4330=m
+# CONFIG_BCM43241 is not set
+CONFIG_BROADCOM_WIFI_RESERVED_MEM=y
+# CONFIG_WLAN_COUNTRY_CODE is not set
+CONFIG_WLAN_REGION_CODE=100
+# CONFIG_HOSTAP is not set
+# CONFIG_IWM is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_MWIFIEX is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_USB_CDC_PHONET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+# CONFIG_PPP_SYNC_TTY is not set
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+# CONFIG_PPPOE is not set
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_KEYRESET is not set
+# CONFIG_INPUT_FBSUSPEND is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_KEYBOARD_CYPRESS_TOUCH=y
+CONFIG_TOUCHKEY_BLN=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_MELFAS_GC is not set
+# CONFIG_TOUCHSCREEN_MELFAS is not set
+# CONFIG_TOUCHSCREEN_MELFAS_MMS is not set
+# CONFIG_TOUCHSCREEN_MMS152 is not set
+# CONFIG_TOUCHSCREEN_MELFAS_NOTE is not set
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+CONFIG_TOUCHSCREEN_ATMEL_MXT224_U1=y
+# CONFIG_TOUCHSCREEN_ATMEL_MXT224_GRANDE is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT224_GC is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT1536E is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT1664S is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT540E is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT224 is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_S3C2410 is not set
+# CONFIG_TOUCHSCREEN_EXYNOS4 is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_MELFAS_TOUCHKEY is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_TOUCHSCREEN_ZINITIX is not set
+# CONFIG_TOUCHSCREEN_MXT1386 is not set
+# CONFIG_TOUCHSCREEN_MXT768E is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_S7301 is not set
+# CONFIG_SEC_TOUCHSCREEN_DVFS_LOCK is not set
+# CONFIG_KEYPAD_MELFAS_TOUCH is not set
+# CONFIG_EPEN_WACOM_G5SP is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_SENSORS_BH1721FVC is not set
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+CONFIG_INPUT_KEYCHORD=y
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_GPIO=y
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_PWM_BEEPER is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_OPTICAL_GP2A is not set
+# CONFIG_OPTICAL_WAKE_ENABLE is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_INPUT_FLIP is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+# CONFIG_VT_CONSOLE is not set
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_CONSOLE is not set
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SAMSUNG=y
+CONFIG_SERIAL_SAMSUNG_UARTS_4=y
+CONFIG_SERIAL_SAMSUNG_UARTS=4
+CONFIG_SERIAL_SAMSUNG_CONSOLE=y
+# CONFIG_SERIAL_SAMSUNG_CONSOLE_SWITCH is not set
+CONFIG_SERIAL_S5PV210=y
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_CSR_GSD4T_CDMA is not set
+
+#
+# Diag Support
+#
+# CONFIG_DIAG_CHAR is not set
+
+#
+# DIAG traffic over USB
+#
+
+#
+# SDIO support for DIAG
+#
+
+#
+# HSIC support for DIAG
+#
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_DCC_TTY is not set
+# CONFIG_RAMOOPS is not set
+CONFIG_S3C_MEM=y
+CONFIG_EXYNOS_MEM=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE is not set
+CONFIG_I2C_GPIO=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+CONFIG_HAVE_S3C2410_I2C=y
+CONFIG_I2C_S3C2410=y
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_GPIO=y
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_S3C64XX is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_BASIC_MMIO is not set
+# CONFIG_GPIO_IT8761E is not set
+CONFIG_GPIO_EXYNOS4=y
+CONFIG_GPIO_PLAT_SAMSUNG=y
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_MAX8997_CHARGER is not set
+# CONFIG_BATTERY_MAX17043_FUELGAUGE is not set
+# CONFIG_BATTERY_MAX17042_FUELGAUGE is not set
+# CONFIG_BATTERY_MAX17047_FUELGAUGE is not set
+# CONFIG_BATTERY_SMB136_CHARGER is not set
+# CONFIG_BATTERY_SAMSUNG_P1X is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_BQ20Z75 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_BATTERY_S3C_ADC is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_BATTERY_SAMSUNG is not set
+# CONFIG_CHARGER_MAX8997 is not set
+CONFIG_CHARGER_MAX8997_U1=y
+# CONFIG_CHARGER_MAX8997_PX is not set
+CONFIG_BATTERY_SEC_U1=y
+# CONFIG_BATTERY_SEC_PX is not set
+CONFIG_CHARGER_MAX8922_U1=y
+CONFIG_BATTERY_MAX17042_FUELGAUGE_U1=y
+# CONFIG_BATTERY_MAX17042_FUELGAUGE_PX is not set
+# CONFIG_SMB136_CHARGER is not set
+# CONFIG_SMB136_CHARGER_Q1 is not set
+# CONFIG_SMB328_CHARGER is not set
+# CONFIG_SMB347_CHARGER is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_SENSORS_EXYNOS4_TMU is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+CONFIG_MFD_SUPPORT=y
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+CONFIG_MFD_MAX8997=y
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MAX8698 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_S5M_CORE is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_TPS65910 is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+CONFIG_REGULATOR_MAX8997=y
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+# CONFIG_MEDIA_CONTROLLER is not set
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+CONFIG_RC_CORE=y
+CONFIG_LIRC=y
+CONFIG_RC_MAP=y
+CONFIG_IR_NEC_DECODER=y
+CONFIG_IR_RC5_DECODER=y
+CONFIG_IR_RC6_DECODER=y
+CONFIG_IR_JVC_DECODER=y
+CONFIG_IR_SONY_DECODER=y
+CONFIG_IR_RC5_SZ_DECODER=y
+CONFIG_IR_LIRC_CODEC=y
+# CONFIG_IR_IMON is not set
+# CONFIG_IR_MCEUSB is not set
+# CONFIG_IR_REDRAT3 is not set
+# CONFIG_IR_STREAMZAP is not set
+# CONFIG_RC_LOOPBACK is not set
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+CONFIG_MEDIA_TUNER_CUSTOMISE=y
+
+#
+# Customize TV tuners
+#
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_CMA_PHYS=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+CONFIG_VIDEO_FIXED_MINOR_RANGES=y
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+CONFIG_VIDEO_IR_I2C=y
+
+#
+# Encoders, decoders, sensors and other helper chips
+#
+
+#
+# Audio decoders, processors and mixers
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_ADV7180 is not set
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA7191 is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_TVP7002 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+CONFIG_VIDEO_M5MO=y
+# CONFIG_VIDEO_M9MO is not set
+CONFIG_VIDEO_S5K5BAFX=y
+# CONFIG_VIDEO_S5K5CCGX_COMMON is not set
+# CONFIG_VIDEO_SR200PC20 is not set
+# CONFIG_VIDEO_SR200PC20M is not set
+# CONFIG_VIDEO_ISX012 is not set
+# CONFIG_VIDEO_SLP_S5K4ECGX is not set
+# CONFIG_VIDEO_SLP_DB8131M is not set
+# CONFIG_VIDEO_S5K4EA is not set
+# CONFIG_VIDEO_S5C73M3 is not set
+# CONFIG_VIDEO_SLP_S5C73M3 is not set
+# CONFIG_VIDEO_IMPROVE_STREAMOFF is not set
+CONFIG_CSI_C=y
+# CONFIG_CSI_D is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# MPEG video encoders
+#
+# CONFIG_VIDEO_CX2341X is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+# CONFIG_VIDEO_AK881X is not set
+
+#
+# Camera sensor devices
+#
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_TCM825X is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+
+#
+# Miscelaneous helper chips
+#
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_SR030PC30 is not set
+# CONFIG_VIDEO_NOON010PC30 is not set
+# CONFIG_SOC_CAMERA is not set
+# CONFIG_VIDEO_SAMSUNG_S5P_FIMC is not set
+CONFIG_SAMSUNG_MFC_DRIVERS=y
+CONFIG_USE_LEGACY_MFC=y
+# CONFIG_USE_V4L2_MFC is not set
+CONFIG_V4L_USB_DRIVERS=y
+# CONFIG_USB_VIDEO_CLASS is not set
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+# CONFIG_USB_GSPCA is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+CONFIG_VIDEO_SAMSUNG=y
+CONFIG_VIDEO_SAMSUNG_V4L2=y
+CONFIG_VIDEO_FIMC=y
+CONFIG_VIDEO_FIMC_RANGE_NARROW=y
+# CONFIG_VIDEO_FIMC_RANGE_WIDE is not set
+# CONFIG_VIDEO_FIMC_DEBUG is not set
+CONFIG_VIDEO_FIMC_MIPI=y
+# CONFIG_VIDEO_FIMC_MIPI_IRQ_DEBUG is not set
+CONFIG_VIDEO_FIMC_DMA_AUTO=y
+# CONFIG_VIDEO_FIMC_FIFO is not set
+CONFIG_VIDEO_TVOUT=y
+CONFIG_VIDEO_TVOUT_2CH_AUDIO=y
+# CONFIG_VIDEO_TVOUT_5_1CH_AUDIO is not set
+# CONFIG_HDMI_CEC is not set
+CONFIG_HDMI_EARJACK_MUTE=y
+CONFIG_HDMI_HPD=y
+# CONFIG_HDMI_CONTROLLED_BY_EXT_IC is not set
+CONFIG_HDMI_SWITCH_HPD=y
+# CONFIG_ANALOG_TVENC is not set
+CONFIG_TV_FB=y
+CONFIG_USER_ALLOC_TVOUT=y
+# CONFIG_LSI_HDMI_AUDIO_CH_EVENT is not set
+# CONFIG_TV_DEBUG is not set
+CONFIG_VIDEO_MFC5X=y
+CONFIG_VIDEO_MFC_MAX_INSTANCE=4
+CONFIG_VIDEO_MFC_MEM_PORT_COUNT=2
+# CONFIG_VIDEO_MFC5X_DEBUG is not set
+CONFIG_VIDEO_UMP=y
+# CONFIG_UMP_DED_ONLY is not set
+CONFIG_UMP_OSMEM_ONLY=y
+# CONFIG_UMP_VCM_ONLY is not set
+CONFIG_UMP_MEM_SIZE=1024
+# CONFIG_VIDEO_UMP_DEBUG is not set
+# CONFIG_VIDEO_TSI is not set
+CONFIG_VIDEO_MALI400MP=y
+# CONFIG_MALI_DED_ONLY is not set
+# CONFIG_MALI_DED_MMU is not set
+CONFIG_MALI_OSMEM_ONLY=y
+# CONFIG_MALI_DED_OSMEM is not set
+# CONFIG_VIDEO_MALI400MP_DEBUG is not set
+# CONFIG_VIDEO_MALI400MP_STREAMLINE_PROFILING is not set
+CONFIG_VIDEO_MALI400MP_DVFS=y
+CONFIG_VIDEO_FIMG2D=y
+# CONFIG_VIDEO_FIMG2D_DEBUG is not set
+CONFIG_VIDEO_FIMG2D3X=y
+# CONFIG_VIDEO_FIMG2D3X_DEBUG is not set
+CONFIG_VIDEO_JPEG=y
+# CONFIG_VIDEO_JPEG_DEBUG is not set
+
+#
+# Reserved memory configurations
+#
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC0=5120
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC1=32644
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC2=25600
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC3=7168
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC0=20480
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC1=34816
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_JPEG=20480
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_TVOUT=16384
+# CONFIG_VIDEO_EXYNOS is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+
+#
+# Mhl(sii9244) device support
+#
+CONFIG_SAMSUNG_MHL=y
+# CONFIG_SAMSUNG_USE_11PIN_CONNECTOR is not set
+# CONFIG_SAMSUNG_SMARTDOCK is not set
+CONFIG_SAMSUNG_WORKAROUND_HPD_GLANCE=y
+# CONFIG_SAMSUNG_MHL_UNPOWERED is not set
+# CONFIG_RADIO_ADAPTERS is not set
+# CONFIG_TDMB is not set
+# CONFIG_ISDBT_FC8100 is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_ION is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_S5P=y
+CONFIG_FB_S5P_SPLASH_SCREEN=y
+# CONFIG_FB_S5P_LCD_INIT is not set
+# CONFIG_FB_S5P_DEBUG is not set
+# CONFIG_FB_S5P_TRACE_UNDERRUN is not set
+CONFIG_FB_S5P_DEFAULT_WINDOW=2
+CONFIG_FB_S5P_NR_BUFFERS=2
+# CONFIG_FB_S5P_VIRTUAL is not set
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMD=9000
+CONFIG_FB_S5P_MDNIE=y
+# CONFIG_FB_MDNIE_PWM is not set
+# CONFIG_FB_S5P_MIPI_DSIM is not set
+CONFIG_FB_S5P_LD9040=y
+# CONFIG_FB_S5P_NT35560 is not set
+# CONFIG_FB_S5P_EXTDSP is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_S3C is not set
+# CONFIG_S5P_MIPI_DSI2 is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+# CONFIG_LCD_PLATFORM is not set
+# CONFIG_LCD_S6E63M0 is not set
+# CONFIG_LCD_MIPI_S6E63M0 is not set
+# CONFIG_LCD_MIPI_S6E8AB0 is not set
+# CONFIG_LCD_MIPI_TC358764 is not set
+# CONFIG_LCD_LD9040 is not set
+# CONFIG_LCD_WA101S is not set
+# CONFIG_LCD_LTE480WV is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+# CONFIG_BACKLIGHT_PWM is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+CONFIG_SND_SOC=y
+# CONFIG_SND_SOC_CACHE_LZO is not set
+CONFIG_SND_SOC_SAMSUNG=y
+CONFIG_SND_SAMSUNG_I2S=y
+CONFIG_SND_SOC_U1_MC1N2=y
+# CONFIG_SND_SOC_SAMSUNG_USE_DMA_WRAPPER is not set
+# CONFIG_SND_SAMSUNG_NORMAL is not set
+# CONFIG_SND_SAMSUNG_LP is not set
+# CONFIG_SND_SAMSUNG_ALP is not set
+CONFIG_SND_SAMSUNG_RP=y
+CONFIG_AUDIO_SAMSUNG_MEMSIZE_SRP=1024
+# CONFIG_SND_SAMSUNG_RP_DEBUG is not set
+# CONFIG_SND_SAMSUNG_I2S_MASTER is not set
+# CONFIG_SND_USE_SUB_MIC is not set
+# CONFIG_SND_USE_THIRD_MIC is not set
+# CONFIG_SND_USE_STEREO_SPEAKER is not set
+# CONFIG_SND_USE_LINEOUT_SWITCH is not set
+# CONFIG_SND_USE_MUIC_SWITCH is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_MC1N2=y
+CONFIG_SND_SOC_USE_EXTERNAL_MIC_BIAS=y
+# CONFIG_SND_SOC_MC1N2_DEBUG is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+# CONFIG_HID_ACRUX is not set
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+# CONFIG_HID_PRODIKEYS is not set
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+# CONFIG_DRAGONRISE_FF is not set
+# CONFIG_HID_EMS_FF is not set
+CONFIG_HID_ELECOM=y
+CONFIG_HID_EZKEY=y
+# CONFIG_HID_KEYTOUCH is not set
+CONFIG_HID_KYE=y
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+CONFIG_HID_GYRATION=y
+# CONFIG_HID_TWINHAN is not set
+CONFIG_HID_KENSINGTON=y
+# CONFIG_HID_LCPOWER is not set
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGIG940_FF is not set
+# CONFIG_LOGIWII_FF is not set
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+# CONFIG_HID_MULTITOUCH is not set
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_PICOLCD=y
+# CONFIG_HID_PICOLCD_FB is not set
+# CONFIG_HID_PICOLCD_BACKLIGHT is not set
+# CONFIG_HID_PICOLCD_LCD is not set
+CONFIG_HID_QUANTA=y
+CONFIG_HID_ROCCAT=y
+CONFIG_HID_ROCCAT_COMMON=y
+# CONFIG_HID_ROCCAT_ARVO is not set
+CONFIG_HID_ROCCAT_KONE=y
+# CONFIG_HID_ROCCAT_KONEPLUS is not set
+# CONFIG_HID_ROCCAT_KOVAPLUS is not set
+# CONFIG_HID_ROCCAT_PYRA is not set
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+# CONFIG_GREENASIA_FF is not set
+CONFIG_HID_SMARTJOYPLUS=y
+# CONFIG_SMARTJOYPLUS_FF is not set
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+# CONFIG_THRUSTMASTER_FF is not set
+CONFIG_HID_WACOM=y
+# CONFIG_HID_WACOM_POWER_SUPPLY is not set
+CONFIG_HID_ZEROPLUS=y
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_HID_ZYDACRON=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB_ARCH_HAS_XHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_HOST_COMPLIANT_TEST is not set
+CONFIG_USB_HOST_NOTIFY=y
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_XHCI_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_S5P=y
+CONFIG_USB_S5P_HSIC0=y
+CONFIG_USB_S5P_HSIC1=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+CONFIG_USB_S3C_OTG_HOST=y
+# CONFIG_USB_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+CONFIG_USB_PRINTER=y
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_QCOM_DIAG_BRIDGE is not set
+# CONFIG_USB_QCOM_MDM_BRIDGE is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_FUSB300 is not set
+# CONFIG_USB_GADGET_R8A66597 is not set
+CONFIG_USB_GADGET_S3C_OTGD=y
+# CONFIG_USB_GADGET_PXA_U2O is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+
+#
+# NOTE: S3C OTG device role enables the controller driver below
+#
+CONFIG_USB_S3C_OTGD=y
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_G_SLP is not set
+CONFIG_USB_G_ANDROID=y
+CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE=y
+CONFIG_USB_ANDROID_SAMSUNG_MTP=y
+CONFIG_USB_DUN_SUPPORT=y
+# CONFIG_USB_ANDROID is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_NOKIA is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_OTG_WAKELOCK is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_CLKGATE=y
+CONFIG_MMC_EMBEDDED_SDIO=y
+CONFIG_MMC_PARANOID_SD_INIT=y
+# CONFIG_MMC_NOT_USE_SANITIZE is not set
+# CONFIG_MMC_POLLING_WAIT_CMD23 is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+# CONFIG_MMC_SELECTIVE_PACKED_CMD_POLICY is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_MSHCI=y
+# CONFIG_MMC_MSHCI_S3C_DMA_MAP is not set
+# CONFIG_MMC_MSHCI_ASYNC_OPS is not set
+CONFIG_MMC_SDHCI=y
+# CONFIG_MMC_SDHCI_PLTFM is not set
+CONFIG_MMC_SDHCI_S3C=y
+CONFIG_MMC_SDHCI_S3C_DMA=y
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_LEDS_SPFCW043 is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_NFC_DEVICES is not set
+CONFIG_SWITCH=y
+CONFIG_SWITCH_GPIO=y
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+CONFIG_RTC_INTF_ALARM=y
+CONFIG_RTC_INTF_ALARM_DEV=y
+# CONFIG_RTC_ALARM_BOOT is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+CONFIG_RTC_DRV_MAX8997=y
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_HAVE_S3C_RTC=y
+CONFIG_RTC_DRV_S3C=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+CONFIG_STAGING=y
+# CONFIG_VIDEO_TM6000 is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_PRISM2_USB is not set
+# CONFIG_ECHO is not set
+# CONFIG_BRCMUTIL is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_R8712U is not set
+# CONFIG_TRANZPORT is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=m
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_RAM_CONSOLE_ENABLE_VERBOSE=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_DATA_SIZE=128
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_ECC_SIZE=16
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_SYMBOL_SIZE=8
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_POLYNOMIAL=0x11d
+# CONFIG_ANDROID_RAM_CONSOLE_EARLY_INIT is not set
+CONFIG_ANDROID_TIMED_OUTPUT=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+# CONFIG_POHMELFS is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_VT6656 is not set
+# CONFIG_IIO is not set
+# CONFIG_XVMALLOC is not set
+# CONFIG_ZRAM is not set
+# CONFIG_FB_SM7XX is not set
+# CONFIG_LIRC_STAGING is not set
+# CONFIG_EASYCAP is not set
+CONFIG_MACH_NO_WESTBRIDGE=y
+# CONFIG_ATH6K_LEGACY is not set
+# CONFIG_USB_ENESTORAGE is not set
+# CONFIG_BCM_WIMAX is not set
+# CONFIG_FT1000 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_SPEAKUP is not set
+# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_VIBETONZ=y
+CONFIG_MOTOR_DRV_MAX8997=y
+# CONFIG_MOTOR_DRV_ISA1200 is not set
+CONFIG_SAMSUNG_MODULES=y
+CONFIG_FM_RADIO=y
+CONFIG_J4FS=m
+CONFIG_FM_SI4709=m
+# CONFIG_FM_SI4705 is not set
+CONFIG_SENSORS_CORE=y
+CONFIG_SENSORS_AK8975C=y
+# CONFIG_SENSORS_BMP180 is not set
+CONFIG_SENSORS_CM3663=y
+# CONFIG_SENSORS_PAS2M110 is not set
+# CONFIG_SENSORS_BMA254 is not set
+# CONFIG_SENSORS_TAOS is not set
+# CONFIG_SENSORS_GP2A is not set
+# CONFIG_SENSORS_GP2A_ANALOG is not set
+# CONFIG_SENSORS_CM36651 is not set
+# CONFIG_SENSORS_BH1721 is not set
+CONFIG_SENSORS_K3DH=y
+CONFIG_SENSORS_K3G=y
+# CONFIG_SENSORS_LSM330DLC is not set
+# CONFIG_SENSORS_LPS331 is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_SAMSUNG_PHONE_SVNET is not set
+CONFIG_ACCESSORY=y
+# CONFIG_30PIN_CONN is not set
+# CONFIG_MHL_SII9234 is not set
+# CONFIG_SEC_KEYBOARD_DOCK is not set
+# CONFIG_HPD_PULL is not set
+# CONFIG_SAMSUNG_MHL_9290 is not set
+# CONFIG_IR_REMOCON is not set
+# CONFIG_EXTCON is not set
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+# CONFIG_EXT4_FS_XATTR is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+CONFIG_ECRYPT_FS=y
+CONFIG_WTL_ENCRYPTION_FILTER=y
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_CEPH_FS is not set
+CONFIG_CIFS=y
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_WEAK_PW_HASH is not set
+# CONFIG_CIFS_UPCALL is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_DFS_UPCALL is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Kernel hacking
+#
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_STACKTRACE is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_MEMORY_INIT is not set
+CONFIG_FRAME_POINTER=y
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_RCU_CPU_STALL_VERBOSE=y
+# CONFIG_LKDTM is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_OC_ETM is not set
+CONFIG_DEBUG_S3C_UART=1
+# CONFIG_CACHE_PERF is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_FIPS=y
+CONFIG_CRYPTO_FIPS_INTEG_OFFSET=0x2B000000
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_TESTS=y
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_NULL=y
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_CRYPTO_CRYPTD=y
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_CRYPTO_TEST=y
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+CONFIG_CRYPTO_SEQIV=y
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTR=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_CRYPTO_GHASH=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_S5P_DEV_ACE is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_REED_SOLOMON=y
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_NLATTR=y
+# CONFIG_AVERAGE is not set
diff -rupN kernel-s2-ics-update7/arch/arm/include/asm/cputype.h kernel/arch/arm/include/asm/cputype.h
--- kernel-s2-ics-update7/arch/arm/include/asm/cputype.h	2012-07-23 16:37:43.000000000 +0800
+++ kernel/arch/arm/include/asm/cputype.h	2012-07-27 21:37:57.000000000 +0800
@@ -8,6 +8,7 @@
 #define CPUID_CACHETYPE	1
 #define CPUID_TCM	2
 #define CPUID_TLBTYPE	3
+#define CPUID_MPIDR	5
 
 #define CPUID_EXT_PFR0	"c1, 0"
 #define CPUID_EXT_PFR1	"c1, 1"
@@ -70,6 +71,11 @@ static inline unsigned int __attribute_c
 	return read_cpuid(CPUID_TCM);
 }
 
+static inline unsigned int __attribute_const__ read_cpuid_mpidr(void)
+{
+	return read_cpuid(CPUID_MPIDR);
+}
+
 /*
  * Intel's XScale3 core supports some v6 features (supersections, L2)
  * but advertises itself as v5 as it does not support the v6 ISA.  For
diff -rupN kernel-s2-ics-update7/arch/arm/include/asm/topology.h kernel/arch/arm/include/asm/topology.h
--- kernel-s2-ics-update7/arch/arm/include/asm/topology.h	2012-07-23 16:37:43.000000000 +0800
+++ kernel/arch/arm/include/asm/topology.h	2012-07-27 21:37:57.000000000 +0800
@@ -1,6 +1,72 @@
 #ifndef _ASM_ARM_TOPOLOGY_H
 #define _ASM_ARM_TOPOLOGY_H
 
+#ifdef CONFIG_ARM_CPU_TOPOLOGY
+
+#include <linux/cpumask.h>
+
+struct cputopo_arm {
+	int thread_id;
+	int core_id;
+	int socket_id;
+	cpumask_t thread_sibling;
+	cpumask_t core_sibling;
+};
+
+extern struct cputopo_arm cpu_topology[NR_CPUS];
+
+#define topology_physical_package_id(cpu)	(cpu_topology[cpu].socket_id)
+#define topology_core_id(cpu)		(cpu_topology[cpu].core_id)
+#define topology_core_cpumask(cpu)	(&cpu_topology[cpu].core_sibling)
+#define topology_thread_cpumask(cpu)	(&cpu_topology[cpu].thread_sibling)
+
+#define mc_capable()	(cpu_topology[0].socket_id != -1)
+#define smt_capable()	(cpu_topology[0].thread_id != -1)
+
+void init_cpu_topology(void);
+void store_cpu_topology(unsigned int cpuid);
+const struct cpumask *cpu_coregroup_mask(unsigned int cpu);
+
+#else
+
+static inline void init_cpu_topology(void) { }
+static inline void store_cpu_topology(unsigned int cpuid) { }
+
+#endif
+
+/* Common values for CPUs */
+#ifndef SD_CPU_INIT
+#define SD_CPU_INIT (struct sched_domain) {				\
+	.min_interval		= 1,					\
+	.max_interval		= 4,					\
+	.busy_factor		= 64,					\
+	.imbalance_pct		= 125,					\
+	.cache_nice_tries	= 1,					\
+	.busy_idx		= 2,					\
+	.idle_idx		= 1,					\
+	.newidle_idx		= 0,					\
+	.wake_idx		= 0,					\
+	.forkexec_idx		= 0,					\
+									\
+	.flags			= 1*SD_LOAD_BALANCE			\
+				| 1*SD_BALANCE_NEWIDLE			\
+				| 1*SD_BALANCE_EXEC			\
+				| 1*SD_BALANCE_FORK			\
+				| 0*SD_BALANCE_WAKE			\
+				| 1*SD_WAKE_AFFINE			\
+				| 0*SD_PREFER_LOCAL			\
+				| 0*SD_SHARE_CPUPOWER			\
+				| 0*SD_SHARE_PKG_RESOURCES		\
+				| 0*SD_SERIALIZE			\
+				| arch_sd_sibling_asym_packing()	\
+				| sd_balance_for_package_power()	\
+				| sd_power_saving_flags()		\
+				,					\
+	.last_balance		= jiffies,				\
+	.balance_interval	= 1,					\
+}
+#endif
+
 #include <asm-generic/topology.h>
 
 #endif /* _ASM_ARM_TOPOLOGY_H */
diff -rupN kernel-s2-ics-update7/arch/arm/Kconfig kernel/arch/arm/Kconfig
--- kernel-s2-ics-update7/arch/arm/Kconfig	2012-07-23 16:37:42.000000000 +0800
+++ kernel/arch/arm/Kconfig	2012-07-28 13:15:05.000000000 +0800
@@ -1413,6 +1413,31 @@ config SMP_ON_UP
 
 	  If you don't know what to do here, say Y.
 
+config ARM_CPU_TOPOLOGY
+	bool "Support cpu topology definition"
+	depends on SMP && CPU_V7
+	default y
+	help
+	  Support ARM cpu topology definition. The MPIDR register defines
+	  affinity between processors which is then used to describe the cpu
+	  topology of an ARM System.
+
+config SCHED_MC
+	bool "Multi-core scheduler support"
+	depends on ARM_CPU_TOPOLOGY
+	help
+	  Multi-core scheduler support improves the CPU scheduler's decision
+	  making when dealing with multi-core CPU chips at a cost of slightly
+	  increased overhead in some places. If unsure say N here.
+
+config SCHED_SMT
+	bool "SMT scheduler support"
+	depends on ARM_CPU_TOPOLOGY
+	help
+	  Improves the CPU scheduler's decision making when dealing with
+	  MultiThreading at a cost of slightly increased overhead in some
+	  places. If unsure say N here.
+
 config HAVE_ARM_SCU
 	bool
 	depends on SMP
diff -rupN kernel-s2-ics-update7/arch/arm/kernel/Makefile kernel/arch/arm/kernel/Makefile
--- kernel-s2-ics-update7/arch/arm/kernel/Makefile	2012-07-23 16:37:42.000000000 +0800
+++ kernel/arch/arm/kernel/Makefile	2012-07-27 21:37:57.000000000 +0800
@@ -62,6 +62,7 @@ obj-$(CONFIG_IWMMXT)		+= iwmmxt.o
 obj-$(CONFIG_CPU_HAS_PMU)	+= pmu.o
 obj-$(CONFIG_HW_PERF_EVENTS)	+= perf_event.o
 AFLAGS_iwmmxt.o			:= -Wa,-mcpu=iwmmxt
+obj-$(CONFIG_ARM_CPU_TOPOLOGY)  += topology.o
 
 ifneq ($(CONFIG_ARCH_EBSA110),y)
   obj-y		+= io.o
diff -rupN kernel-s2-ics-update7/arch/arm/kernel/smp.c kernel/arch/arm/kernel/smp.c
--- kernel-s2-ics-update7/arch/arm/kernel/smp.c	2012-07-23 16:37:42.000000000 +0800
+++ kernel/arch/arm/kernel/smp.c	2012-07-27 21:37:57.000000000 +0800
@@ -31,6 +31,7 @@
 #include <asm/cacheflush.h>
 #include <asm/cpu.h>
 #include <asm/cputype.h>
+#include <asm/topology.h>
 #include <asm/mmu_context.h>
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
@@ -271,6 +272,8 @@ static void __cpuinit smp_store_cpu_info
 	struct cpuinfo_arm *cpu_info = &per_cpu(cpu_data, cpuid);
 
 	cpu_info->loops_per_jiffy = loops_per_jiffy;
+
+	store_cpu_topology(cpuid);
 }
 
 /*
@@ -372,6 +375,8 @@ void __init smp_prepare_cpus(unsigned in
 {
 	unsigned int ncores = num_possible_cpus();
 
+	init_cpu_topology();
+
 	smp_store_cpu_info(smp_processor_id());
 
 	/*
diff -rupN kernel-s2-ics-update7/arch/arm/kernel/topology.c kernel/arch/arm/kernel/topology.c
--- kernel-s2-ics-update7/arch/arm/kernel/topology.c	1970-01-01 07:30:00.000000000 +0730
+++ kernel/arch/arm/kernel/topology.c	2012-07-27 21:37:57.000000000 +0800
@@ -0,0 +1,589 @@
+/*
+ * arch/arm/kernel/topology.c
+ *
+ * Copyright (C) 2011 Linaro Limited.
+ * Written by: Vincent Guittot
+ *
+ * based on arch/sh/kernel/topology.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/cpu.h>
+#include <linux/cpumask.h>
+#include <linux/init.h>
+#include <linux/percpu.h>
+#include <linux/node.h>
+#include <linux/nodemask.h>
+#include <linux/sched.h>
+#include <linux/cpumask.h>
+#include <linux/cpuset.h>
+
+#ifdef CONFIG_CPU_FREQ
+#include <linux/cpufreq.h>
+#endif
+
+#ifdef CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>	/* for copy_from_user */
+#endif
+
+#include <asm/cputype.h>
+#include <asm/topology.h>
+
+#define MPIDR_SMP_BITMASK (0x3 << 30)
+#define MPIDR_SMP_VALUE (0x2 << 30)
+
+#define MPIDR_MT_BITMASK (0x1 << 24)
+
+/*
+ * These masks reflect the current use of the affinity levels.
+ * The affinity level can be up to 16 bits according to ARM ARM
+ */
+
+#define MPIDR_LEVEL0_MASK 0x3
+#define MPIDR_LEVEL0_SHIFT 0
+
+#define MPIDR_LEVEL1_MASK 0xF
+#define MPIDR_LEVEL1_SHIFT 8
+
+#define MPIDR_LEVEL2_MASK 0xFF
+#define MPIDR_LEVEL2_SHIFT 16
+
+struct cputopo_arm cpu_topology[NR_CPUS];
+
+/*
+ * cpu power scale management
+ */
+
+/*
+ * a per cpu data structure should be better because each cpu is mainly
+ * using its own cpu_power even it's not always true because of
+ * no_hz_idle_balance
+ */
+
+static DEFINE_PER_CPU(unsigned int, cpu_scale);
+
+/*
+ * cpu topology mask management
+ */
+
+unsigned int advanced_topology = 1;
+
+static void normal_cpu_topology_mask(void);
+static void (*set_cpu_topology_mask)(void) = normal_cpu_topology_mask;
+
+#ifdef CONFIG_CPU_FREQ
+/*
+ * This struct describes parameters to compute cpu_power
+ */
+struct cputopo_power {
+	int id;
+	int max; /* max idx in the table */
+	unsigned int step; /* frequency step for the table */
+	unsigned int *table; /* table of cpu_power */
+};
+
+/* default table with one default cpu_power value */
+unsigned int table_default_power[1] = {
+	1024
+};
+
+static struct cputopo_power default_cpu_power = {
+	.max  = 1,
+	.step = 1,
+	.table = table_default_power,
+};
+
+/* CA-9 table with cpufreq modifying cpu_power */
+#define CPU_MAX_FREQ 10
+/* we use a 200Mhz step for scaling cpu power */
+#define CPU_TOPO_FREQ_STEP 200000
+/* This table sets the cpu_power scale of a cpu according to 2 inputs which are
+ * the frequency and the sched_mc mode. The content of this table could be SoC
+ * specific so we should add a method to overwrite this default table.
+ * TODO: Study how to use DT for setting this table
+ */
+unsigned int table_ca9_power[CPU_MAX_FREQ] = {
+/* freq< 200   400   600   800  1000  1200  1400  1600  1800  other*/
+	4096, 4096, 4096, 1024, 1024, 1024, 1024, 1024, 1024, 1024, /* Power save mode CA9 MP */
+};
+
+static struct cputopo_power CA9_cpu_power = {
+	.max  = CPU_MAX_FREQ,
+	.step = CPU_TOPO_FREQ_STEP,
+	.table = table_ca9_power,
+};
+
+#define ARM_CORTEX_A9_DEFAULT_SCALE 0
+#define ARM_CORTEX_A9_POWER_SCALE 1
+/* This table list all possible cpu power configuration */
+struct cputopo_power *table_config[2] = {
+	&default_cpu_power,
+	&CA9_cpu_power,
+};
+
+struct cputopo_scale {
+	int id;
+	int freq;
+	struct cputopo_power *power;
+};
+
+/*
+ * The table will be mostly used by one cpu which will update the
+ * configuration for all cpu on a cpufreq notification
+ * or a sched_mc level change
+ */
+static struct cputopo_scale cpu_power[NR_CPUS];
+
+static void set_cpufreq_scale(unsigned int cpuid, unsigned int freq)
+{
+	unsigned int idx;
+
+	cpu_power[cpuid].freq = freq;
+
+	idx = freq / cpu_power[cpuid].power->step;
+	if (idx >= cpu_power[cpuid].power->max)
+		idx = cpu_power[cpuid].power->max - 1;
+
+	per_cpu(cpu_scale, cpuid) = cpu_power[cpuid].power->table[idx];
+	smp_wmb();
+}
+
+static void set_power_scale(unsigned int cpu, unsigned int idx)
+{
+	cpu_power[cpu].id = idx;
+	cpu_power[cpu].power = table_config[idx];
+
+	set_cpufreq_scale(cpu, cpu_power[cpu].freq);
+}
+
+static int topo_cpufreq_transition(struct notifier_block *nb,
+	unsigned long state, void *data)
+{
+	struct cpufreq_freqs *freqs = data;
+
+	if (state == CPUFREQ_POSTCHANGE || state == CPUFREQ_RESUMECHANGE)
+		set_cpufreq_scale(freqs->cpu, freqs->new);
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block topo_cpufreq_nb = {
+	.notifier_call = topo_cpufreq_transition,
+};
+
+static int topo_cpufreq_init(void)
+{
+	unsigned int cpu;
+
+	/* TODO set initial value according to current freq */
+
+	/* init core mask */
+	for_each_possible_cpu(cpu) {
+		cpu_power[cpu].freq = 0;
+		cpu_power[cpu].power = &default_cpu_power;
+	}
+
+	return cpufreq_register_notifier(&topo_cpufreq_nb,
+			CPUFREQ_TRANSITION_NOTIFIER);
+}
+#else
+#define ARM_CORTEX_A9_DEFAULT_SCALE 0
+#define ARM_CORTEX_A9_POWER_SCALE 0
+/* This table list all possible cpu power configuration */
+unsigned int table_config[1] = {
+	1024,
+};
+
+static void set_power_scale(unsigned int cpu, unsigned int idx)
+{
+	per_cpu(cpu_scale, cpu) = table_config[idx];
+}
+
+static inline int topo_cpufreq_init(void) {return 0; }
+#endif
+
+static int init_cpu_power_scale(void)
+{
+	/* register cpufreq notifer */
+	topo_cpufreq_init();
+
+	/* Do we need to change default config */
+	advanced_topology = 1;
+
+	/* Force a cpu topology update */
+	rebuild_sched_domains();
+
+	return 0;
+}
+
+core_initcall(init_cpu_power_scale);
+
+/*
+ * Update the cpu power
+ */
+
+unsigned long arch_scale_freq_power(struct sched_domain *sd, int cpu)
+{
+	return per_cpu(cpu_scale, cpu);
+}
+
+/*
+ * sched_domain flag configuration
+ */
+/* TODO add a config flag for this function */
+int arch_sd_sibling_asym_packing(void)
+{
+	if (sched_smt_power_savings || sched_mc_power_savings)
+		return SD_ASYM_PACKING;
+	return 0;
+}
+
+/*
+ * default topology function
+ */
+
+const struct cpumask *cpu_coregroup_mask(unsigned int cpu)
+{
+	return &cpu_topology[cpu].core_sibling;
+}
+
+/*
+ * clear cpu topology masks
+ */
+static void clear_cpu_topology_mask(void)
+{
+	unsigned int cpuid;
+	for_each_possible_cpu(cpuid) {
+		struct cputopo_arm *cpuid_topo = &(cpu_topology[cpuid]);
+		cpumask_clear(&cpuid_topo->core_sibling);
+		cpumask_clear(&cpuid_topo->thread_sibling);
+	}
+	smp_wmb();
+}
+
+/*
+ * default_cpu_topology_mask set the core and thread mask as described in the
+ * ARM ARM
+ */
+static inline void default_cpu_topology_mask(unsigned int cpuid)
+{
+	struct cputopo_arm *cpuid_topo = &cpu_topology[cpuid];
+	unsigned int cpu;
+
+	for_each_possible_cpu(cpu) {
+		struct cputopo_arm *cpu_topo = &cpu_topology[cpu];
+
+		if (cpuid_topo->socket_id == cpu_topo->socket_id) {
+			cpumask_set_cpu(cpuid, &cpu_topo->core_sibling);
+			if (cpu != cpuid)
+				cpumask_set_cpu(cpu,
+					&cpuid_topo->core_sibling);
+
+			if (cpuid_topo->core_id == cpu_topo->core_id) {
+				cpumask_set_cpu(cpuid,
+					&cpu_topo->thread_sibling);
+				if (cpu != cpuid)
+					cpumask_set_cpu(cpu,
+						&cpuid_topo->thread_sibling);
+			}
+		}
+	}
+	smp_wmb();
+}
+
+static void normal_cpu_topology_mask(void)
+{
+	unsigned int cpuid;
+
+	for_each_possible_cpu(cpuid) {
+		default_cpu_topology_mask(cpuid);
+		set_power_scale(cpuid, ARM_CORTEX_A9_DEFAULT_SCALE);
+	}
+	smp_wmb();
+}
+
+/*
+ * For Cortex-A9 MPcore, we emulate a multi-package topology in power mode.
+ * The goal is to gathers tasks on 1 virtual package
+ */
+static void power_cpu_topology_mask_CA9(void)
+{
+	unsigned int cpuid, cpu;
+
+	for_each_possible_cpu(cpuid) {
+		struct cputopo_arm *cpuid_topo = &cpu_topology[cpuid];
+
+		for_each_possible_cpu(cpu) {
+			struct cputopo_arm *cpu_topo = &cpu_topology[cpu];
+
+			if ((cpuid_topo->socket_id == cpu_topo->socket_id)
+			&& ((cpuid & 0x1) == (cpu & 0x1))) {
+				cpumask_set_cpu(cpuid, &cpu_topo->core_sibling);
+				if (cpu != cpuid)
+					cpumask_set_cpu(cpu,
+						&cpuid_topo->core_sibling);
+
+				if (cpuid_topo->core_id == cpu_topo->core_id) {
+					cpumask_set_cpu(cpuid,
+						&cpu_topo->thread_sibling);
+					if (cpu != cpuid)
+						cpumask_set_cpu(cpu,
+							&cpuid_topo->thread_sibling);
+				}
+			}
+		}
+		set_power_scale(cpuid, ARM_CORTEX_A9_POWER_SCALE);
+	}
+	smp_wmb();
+}
+
+#define ARM_FAMILY_MASK 0xFF0FFFF0
+#define ARM_CORTEX_A9_FAMILY 0x410FC090
+
+/* update_cpu_topology_policy select a cpu topology policy according to the
+ * available cores.
+ * TODO: The current version assumes that all cores are exactly the same which
+ * might not be true. We need to update it to take into account various
+ * configuration among which system with different kind of core.
+ */
+static int update_cpu_topology_policy(void)
+{
+	unsigned long cpuid;
+
+	if (sched_mc_power_savings == POWERSAVINGS_BALANCE_NONE) {
+		set_cpu_topology_mask = normal_cpu_topology_mask;
+		return 0;
+	}
+
+	cpuid = read_cpuid_id();
+	cpuid &= ARM_FAMILY_MASK;
+
+	switch (cpuid) {
+	case ARM_CORTEX_A9_FAMILY:
+		set_cpu_topology_mask = power_cpu_topology_mask_CA9;
+	break;
+	default:
+		set_cpu_topology_mask = normal_cpu_topology_mask;
+	break;
+	}
+
+	return 0;
+}
+
+/*
+ * store_cpu_topology is called at boot when only one cpu is running
+ * and with the mutex cpu_hotplug.lock locked, when several cpus have booted,
+ * which prevents simultaneous write access to cpu_topology array
+ */
+void store_cpu_topology(unsigned int cpuid)
+{
+	struct cputopo_arm *cpuid_topo = &cpu_topology[cpuid];
+	unsigned int mpidr;
+
+	/* If the cpu topology has been already set, just return */
+	if (cpuid_topo->core_id != -1)
+		return;
+
+	mpidr = read_cpuid_mpidr();
+
+	/* create cpu topology mapping */
+	if ((mpidr & MPIDR_SMP_BITMASK) == MPIDR_SMP_VALUE) {
+		/*
+		 * This is a multiprocessor system
+		 * multiprocessor format & multiprocessor mode field are set
+		 */
+
+		if (mpidr & MPIDR_MT_BITMASK) {
+			/* core performance interdependency */
+			cpuid_topo->thread_id = (mpidr >> MPIDR_LEVEL0_SHIFT)
+				& MPIDR_LEVEL0_MASK;
+			cpuid_topo->core_id = (mpidr >> MPIDR_LEVEL1_SHIFT)
+				& MPIDR_LEVEL1_MASK;
+			cpuid_topo->socket_id = (mpidr >> MPIDR_LEVEL2_SHIFT)
+				& MPIDR_LEVEL2_MASK;
+		} else {
+			/* largely independent cores */
+			cpuid_topo->thread_id = -1;
+			cpuid_topo->core_id = (mpidr >> MPIDR_LEVEL0_SHIFT)
+				& MPIDR_LEVEL0_MASK;
+			cpuid_topo->socket_id = (mpidr >> MPIDR_LEVEL1_SHIFT)
+				& MPIDR_LEVEL1_MASK;
+		}
+	} else {
+		/*
+		 * This is an uniprocessor system
+		 * we are in multiprocessor format but uniprocessor system
+		 * or in the old uniprocessor format
+		 */
+		cpuid_topo->thread_id = -1;
+		cpuid_topo->core_id = 0;
+		cpuid_topo->socket_id = -1;
+	}
+
+	/*
+	 * The core and thread sibling masks can also be updated during the
+	 * call of arch_update_cpu_topology
+	 */
+	default_cpu_topology_mask(cpuid);
+
+	printk(KERN_INFO "CPU%u: thread %d, cpu %d, socket %d, mpidr %x\n",
+		cpuid, cpu_topology[cpuid].thread_id,
+		cpu_topology[cpuid].core_id,
+		cpu_topology[cpuid].socket_id, mpidr);
+}
+
+/*
+ * arch_update_cpu_topology is called by the scheduler before building
+ * a new sched_domain hierarchy.
+ */
+int arch_update_cpu_topology(void)
+{
+	if (!advanced_topology)
+		return 0;
+
+	/* clear core threads mask */
+	clear_cpu_topology_mask();
+
+	/* set topology policy */
+	update_cpu_topology_policy();
+
+	/* set topology mask and power */
+	(*set_cpu_topology_mask)();
+
+	return 1;
+}
+
+/*
+ * init_cpu_topology is called at boot when only one cpu is running
+ * which prevent simultaneous write access to cpu_topology array
+ */
+void init_cpu_topology(void)
+{
+	unsigned int cpu;
+
+	/* init core mask */
+	for_each_possible_cpu(cpu) {
+		struct cputopo_arm *cpu_topo = &(cpu_topology[cpu]);
+
+		cpu_topo->thread_id = -1;
+		cpu_topo->core_id =  -1;
+		cpu_topo->socket_id = -1;
+		cpumask_clear(&cpu_topo->core_sibling);
+		cpumask_clear(&cpu_topo->thread_sibling);
+
+		per_cpu(cpu_scale, cpu) = SCHED_POWER_SCALE;
+	}
+	smp_wmb();
+}
+
+/*
+ * debugfs interface for scaling cpu power
+ */
+
+#ifdef CONFIG_DEBUG_FS
+static struct dentry *topo_debugfs_root;
+
+static ssize_t dbg_write(struct file *file, const char __user *buf,
+						size_t size, loff_t *off)
+{
+	unsigned int *value = file->f_dentry->d_inode->i_private;
+	char cdata[128];
+	unsigned long tmp;
+	unsigned int cpu;
+
+	if (size < (sizeof(cdata)-1)) {
+		if (copy_from_user(cdata, buf, size))
+			return -EFAULT;
+		cdata[size] = 0;
+		if (!strict_strtoul(cdata, 10, &tmp)) {
+			*value = tmp;
+
+#ifdef CONFIG_CPU_FREQ
+			for_each_online_cpu(cpu)
+				set_power_scale(cpu, cpu_power[cpu].id);
+#endif
+		}
+		return size;
+	}
+	return -EINVAL;
+}
+
+static ssize_t dbg_read(struct file *file, char __user *buf,
+						size_t size, loff_t *off)
+{
+	unsigned int *value = file->f_dentry->d_inode->i_private;
+	char cdata[128];
+	unsigned int len;
+
+	len = sprintf(cdata, "%u\n", *value);
+	return simple_read_from_buffer(buf, size, off, cdata, len);
+}
+
+static const struct file_operations debugfs_fops = {
+	.read = dbg_read,
+	.write = dbg_write,
+};
+
+static struct dentry *topo_debugfs_register(unsigned int cpu,
+						struct dentry *parent)
+{
+	struct dentry *cpu_d, *d;
+	char cpu_name[16];
+
+	sprintf(cpu_name, "cpu%u", cpu);
+
+	cpu_d = debugfs_create_dir(cpu_name, parent);
+	if (!cpu_d)
+		return NULL;
+
+	d = debugfs_create_file("cpu_power", S_IRUGO  | S_IWUGO,
+				cpu_d, &per_cpu(cpu_scale, cpu), &debugfs_fops);
+	if (!d)
+		goto err_out;
+
+#ifdef CONFIG_CPU_FREQ
+	d = debugfs_create_file("scale", S_IRUGO | S_IWUGO,
+				cpu_d, &cpu_power[cpu].id, &debugfs_fops);
+	if (!d)
+		goto err_out;
+
+	d = debugfs_create_file("freq", S_IRUGO,
+				cpu_d, &cpu_power[cpu].freq, &debugfs_fops);
+	if (!d)
+		goto err_out;
+#endif
+	return cpu_d;
+
+err_out:
+	debugfs_remove_recursive(cpu_d);
+	return NULL;
+}
+
+static int __init topo_debugfs_init(void)
+{
+	struct dentry *d;
+	unsigned int cpu;
+
+	d = debugfs_create_dir("cpu_topo", NULL);
+	if (!d)
+		return -ENOMEM;
+	topo_debugfs_root = d;
+
+	for_each_possible_cpu(cpu) {
+		d = topo_debugfs_register(cpu, topo_debugfs_root);
+		if (d == NULL)
+			goto err_out;
+	}
+	return 0;
+
+err_out:
+	debugfs_remove_recursive(topo_debugfs_root);
+	return -ENOMEM;
+}
+
+late_initcall(topo_debugfs_init);
+#endif
diff -rupN kernel-s2-ics-update7/arch/arm/mach-exynos/dvfs-hotplug.c kernel/arch/arm/mach-exynos/dvfs-hotplug.c
--- kernel-s2-ics-update7/arch/arm/mach-exynos/dvfs-hotplug.c	2012-07-23 16:37:44.000000000 +0800
+++ kernel/arch/arm/mach-exynos/dvfs-hotplug.c	2012-07-27 21:37:57.000000000 +0800
@@ -18,6 +18,7 @@
 #include <linux/reboot.h>
 #include <linux/suspend.h>
 #include <linux/io.h>
+#include <linux/earlysuspend.h>
 
 #include <plat/cpu.h>
 
@@ -31,10 +32,19 @@ static unsigned int freq_min = -1UL;
 
 static unsigned int can_hotplug;
 
+static bool screen_off;
+
 static void exynos4_integrated_dvfs_hotplug(unsigned int freq_old,
 					unsigned int freq_new)
 {
 	total_num_target_freq++;
+
+	if (screen_off) {
+		if (!cpu_online(1)) {
+                return; //if screen off and 1-core then don't hotplug
+		}
+	}
+
 	freq_in_trg = 800000;
 
 	if ((freq_old >= freq_in_trg) && (freq_new >= freq_in_trg)) {
@@ -138,6 +148,22 @@ static struct notifier_block pm_hotplug 
 	.notifier_call = hotplug_pm_transition,
 };
 
+static void hotplug_early_suspend(struct early_suspend *handler)
+{
+	screen_off = true;
+}
+
+static void hotplug_late_resume(struct early_suspend *handler)
+{
+	screen_off = false;
+}
+
+static struct early_suspend hotplug_early_suspend_notifier = {
+	.suspend = hotplug_early_suspend,
+	.resume = hotplug_late_resume,
+	.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN,
+};
+
 /*
  * Note : This function should be called after intialization of CPUFreq
  * driver for exynos4. The cpufreq_frequency_table for exynos4 should be
@@ -173,6 +199,8 @@ static int __init exynos4_integrated_dvf
 
 	register_pm_notifier(&pm_hotplug);
 
+	register_early_suspend(&hotplug_early_suspend_notifier);
+
 	return cpufreq_register_notifier(&dvfs_hotplug,
 					 CPUFREQ_TRANSITION_NOTIFIER);
 }
diff -rupN kernel-s2-ics-update7/arch/arm/mach-exynos/stand-hotplug.c kernel/arch/arm/mach-exynos/stand-hotplug.c
--- kernel-s2-ics-update7/arch/arm/mach-exynos/stand-hotplug.c	2012-07-23 16:37:44.000000000 +0800
+++ kernel/arch/arm/mach-exynos/stand-hotplug.c	2012-07-27 21:37:57.000000000 +0800
@@ -87,7 +87,7 @@
 
 #define HOTPLUG_UNLOCKED 0
 #define HOTPLUG_LOCKED 1
-#define PM_HOTPLUG_DEBUG 1
+#define PM_HOTPLUG_DEBUG 0
 #define NUM_CPUS num_possible_cpus()
 #define CPULOAD_TABLE (NR_CPUS + 1)
 
diff -rupN kernel-s2-ics-update7/drivers/cpufreq/cpufreq_ondemand.c kernel/drivers/cpufreq/cpufreq_ondemand.c
--- kernel-s2-ics-update7/drivers/cpufreq/cpufreq_ondemand.c	2012-07-23 16:38:04.000000000 +0800
+++ kernel/drivers/cpufreq/cpufreq_ondemand.c	2012-07-27 21:37:57.000000000 +0800
@@ -945,7 +945,8 @@ static int __init cpufreq_gov_dbs_init(v
 
 	idle_time = get_cpu_idle_time_us(cpu, &wall);
 	put_cpu();
-	if (idle_time != -1ULL) {
+	//if (idle_time != -1ULL) {
+	if (0) { // Disable micro accounting
 		/* Idle micro accounting is supported. Use finer thresholds */
 		dbs_tuners_ins.up_threshold = MICRO_FREQUENCY_UP_THRESHOLD;
 		dbs_tuners_ins.down_differential =
diff -rupN kernel-s2-ics-update7/drivers/media/video/samsung/mali/Makefile kernel/drivers/media/video/samsung/mali/Makefile
--- kernel-s2-ics-update7/drivers/media/video/samsung/mali/Makefile	2012-07-23 16:38:00.000000000 +0800
+++ kernel/drivers/media/video/samsung/mali/Makefile	2012-07-27 21:37:57.000000000 +0800
@@ -115,7 +115,7 @@ DEFINES += -DMALI_POWER_MGMT_TEST_SUITE=
 DEFINES += -DMALI_MAJOR_PREDEFINE=$(USING_MALI_MAJOR_PREDEFINE)
 DEFINES += -DMALI_DVFS_ENABLED=$(USING_MALI_DVFS_ENABLED)
 DEFINES += -DUSING_MALI_PMM_EARLYSUSPEND=$(USING_MALI_PMM_EARLYSUSPEND)
-DEFINES += -DMALI_STATE_TRACKING=1
+DEFINES += -DMALI_STATE_TRACKING=0
 DEFINES += -DMALI_OS_MEMORY_KERNEL_BUFFER_SIZE_IN_MB=$(OS_MEMORY_KERNEL_BUFFER_SIZE_IN_MB)
 DEFINES += -DMALI_TRACEPOINTS_ENABLED=$(USING_TRACEPOINTS)
 DEFINES += -DMALI_REBOOTNOTIFIER
diff -rupN kernel-s2-ics-update7/drivers/media/video/samsung/mali/platform/orion-m400/mali_platform_dvfs.c kernel/drivers/media/video/samsung/mali/platform/orion-m400/mali_platform_dvfs.c
--- kernel-s2-ics-update7/drivers/media/video/samsung/mali/platform/orion-m400/mali_platform_dvfs.c	2012-07-23 16:38:00.000000000 +0800
+++ kernel/drivers/media/video/samsung/mali/platform/orion-m400/mali_platform_dvfs.c	2012-07-27 21:37:57.000000000 +0800
@@ -68,8 +68,8 @@ mali_dvfs_staycount_table mali_dvfs_stay
 
 /*dvfs threshold*/
 mali_dvfs_threshold_table mali_dvfs_threshold[MALI_DVFS_STEPS]={
-	/*step 0*/{((int)((255*0)/100)), ((int)((255*85)/100))},
-	/*step 1*/{((int)((255*75)/100)), ((int)((255*100)/100))} };
+	/*step 0*/{((int)((255*0)/100)), ((int)((255*65)/100))}, //0-85
+	/*step 1*/{((int)((255*25)/100)), ((int)((255*100)/100))} }; //75-100
 
 /*dvfs status*/
 mali_dvfs_currentstatus maliDvfsStatus;
diff -rupN kernel-s2-ics-update7/drivers/mmc/host/mshci.c kernel/drivers/mmc/host/mshci.c
--- kernel-s2-ics-update7/drivers/mmc/host/mshci.c	2012-07-23 16:38:05.000000000 +0800
+++ kernel/drivers/mmc/host/mshci.c	2012-07-27 21:38:35.000000000 +0800
@@ -2045,7 +2045,7 @@ int mshci_add_host(struct mshci_host *ho
 	mmc->ops = &mshci_ops;
 	mmc->f_min = 400000;
 	mmc->f_max = host->max_clk;
-	mmc->caps |= MMC_CAP_SDIO_IRQ | MMC_CAP_ERASE;
+	mmc->caps |= MMC_CAP_SDIO_IRQ;// | MMC_CAP_ERASE;
 
 	mmc->caps |= MMC_CAP_4_BIT_DATA;
 
diff -rupN kernel-s2-ics-update7/drivers/mmc/host/sdhci.c kernel/drivers/mmc/host/sdhci.c
--- kernel-s2-ics-update7/drivers/mmc/host/sdhci.c	2012-07-23 16:38:05.000000000 +0800
+++ kernel/drivers/mmc/host/sdhci.c	2012-07-27 21:38:54.000000000 +0800
@@ -2611,7 +2611,7 @@ int sdhci_add_host(struct sdhci_host *ho
 	else
 		mmc->max_discard_to = (1 << 27) / host->timeout_clk;
 
-	mmc->caps |= MMC_CAP_SDIO_IRQ | MMC_CAP_ERASE;
+	mmc->caps |= MMC_CAP_SDIO_IRQ;// | MMC_CAP_ERASE;
 
 	if (host->quirks & SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12)
 		host->flags |= SDHCI_AUTO_CMD12;
diff -rupN kernel-s2-ics-update7/drivers/power/max17042_fuelgauge_u1.c kernel/drivers/power/max17042_fuelgauge_u1.c
--- kernel-s2-ics-update7/drivers/power/max17042_fuelgauge_u1.c	2012-07-23 16:38:02.000000000 +0800
+++ kernel/drivers/power/max17042_fuelgauge_u1.c	2012-07-27 21:37:57.000000000 +0800
@@ -513,7 +513,7 @@ static void max17042_work(struct work_st
 			dev_info(&chip->client->dev,
 				"fuel alert already activated (raw:%d)\n",
 				chip->raw_soc);
-	} else if (chip->raw_soc == chip->fuel_alert_soc) {
+	} else if (chip->raw_soc >= chip->fuel_alert_soc) {
 		if (chip->is_fuel_alerted) {
 			wake_unlock(&chip->fuel_alert_wake_lock);
 			chip->is_fuel_alerted = false;
diff -rupN kernel-s2-ics-update7/drivers/power/sec_battery_u1.c kernel/drivers/power/sec_battery_u1.c
--- kernel-s2-ics-update7/drivers/power/sec_battery_u1.c	2012-07-23 16:38:02.000000000 +0800
+++ kernel/drivers/power/sec_battery_u1.c	2012-07-27 21:37:57.000000000 +0800
@@ -1446,7 +1446,7 @@ static int sec_bat_enable_charging_main(
 		switch (info->cable_type) {
 		case CABLE_TYPE_USB:
 			val_type.intval = POWER_SUPPLY_STATUS_CHARGING;
-			val_chg_current.intval = 450;	/* mA */
+			val_chg_current.intval = 650; //450;	/* mA */
 			break;
 		case CABLE_TYPE_AC:
 			val_type.intval = POWER_SUPPLY_STATUS_CHARGING;
@@ -1454,7 +1454,7 @@ static int sec_bat_enable_charging_main(
 			break;
 		case CABLE_TYPE_MISC:
 			val_type.intval = POWER_SUPPLY_STATUS_CHARGING;
-			val_chg_current.intval = 450;	/* mA */
+			val_chg_current.intval = 650; //450;	/* mA */
 			break;
 		default:
 			dev_err(info->dev, "%s: Invalid func use\n", __func__);
@@ -1535,21 +1535,21 @@ static int sec_bat_enable_charging_sub(s
 			switch (info->cable_type) {
 			case CABLE_TYPE_USB:
 				val_type.intval = POWER_SUPPLY_STATUS_CHARGING;
-				val_chg_current.intval = 450;	/* mA */
+				val_chg_current.intval = 650; //450;	/* mA */
 				break;
 			case CABLE_TYPE_AC:
 				val_type.intval = POWER_SUPPLY_STATUS_CHARGING;
 #if defined(CONFIG_TARGET_LOCALE_NAATT)
 				if (info->batt_temp_ext ==
 				    BATT_TEMP_EXT_CAMCORDING_HIGH)
-					val_chg_current.intval = 450;	/* mA */
+					val_chg_current.intval = 650; //450;	/* mA */
 				else
 #endif
 					val_chg_current.intval = 650;	/* mA */
 				break;
 			case CABLE_TYPE_MISC:
 				val_type.intval = POWER_SUPPLY_STATUS_CHARGING;
-				val_chg_current.intval = 450;	/* mA */
+				val_chg_current.intval = 650; //450;	/* mA */
 				break;
 			default:
 				dev_err(info->dev, "%s: Invalid func use\n",
@@ -2745,7 +2745,7 @@ static ssize_t sec_bat_store(struct devi
 					switch (info->cable_type) {
 					case CABLE_TYPE_USB:
 					case CABLE_TYPE_MISC:
-						value.intval = 450;	/* mA */
+						value.intval = 650; //450;	/* mA */
 						break;
 					case CABLE_TYPE_AC:
 						value.intval = 650;	/* mA */
diff -rupN kernel-s2-ics-update7/drivers/samsung/j4fs/fsd_common.c kernel/drivers/samsung/j4fs/fsd_common.c
--- kernel-s2-ics-update7/drivers/samsung/j4fs/fsd_common.c	1970-01-01 07:30:00.000000000 +0730
+++ kernel/drivers/samsung/j4fs/fsd_common.c	2012-07-27 21:37:57.000000000 +0800
@@ -0,0 +1,2053 @@
+/*
+ * Copyright (C) 2008, 2009,  Samsung Electronics Co. Ltd. All Rights Reserved.
+ *       Written by Linux Lab, MITs Development Team, Mobile Communication Division.
+ */
+
+/*
+ * fsd_common.c
+ *
+ * File System Driver
+ *
+ *
+ * 2009.02 - First editing by SungHwan.yun <sunghwan.yun@samsung.com> @LDK@
+ *
+ * 2009.03 - Currently managed by  SungHwan.yun <sunghwan.yun@samsung.com> @LDK@
+ *
+ */
+#include <linux/slab.h>
+#include "j4fs.h"
+
+#ifndef __KERNEL__
+#include <asm/util.h>
+#endif
+
+j4fs_device_info device_info;
+unsigned int j4fs_traceMask=0;
+unsigned int j4fs_PORMask=0;
+unsigned int j4fs_PORCount=0;
+unsigned int j4fs_rw_start=0;
+j4fs_header ro_j4fs_header[J4FS_MAX_RO_FILES_NUMBER];
+int ro_j4fs_header_count=0;
+int j4fs_panic=0;
+
+#ifdef J4FS_TRANSACTION_LOGGING
+unsigned int j4fs_next_sequence=0;
+unsigned int j4fs_transaction_next_offset=0xffffffff;
+#endif
+
+int is_invalid_j4fs_rw_start()
+{
+	if((j4fs_rw_start<device_info.j4fs_offset) ||(j4fs_rw_start>= device_info.j4fs_end) ||
+		(ro_j4fs_header_count>=2 &&  ((ro_j4fs_header[ro_j4fs_header_count-2].link+ro_j4fs_header[ro_j4fs_header_count-1].length)>j4fs_rw_start)) ||
+		(ro_j4fs_header_count==1 && ((device_info.j4fs_offset+ro_j4fs_header[ro_j4fs_header_count-1].length)>j4fs_rw_start)))
+		return 1;
+	else return 0;
+}
+
+/*
+  * This function reads count number of bytes from the file specified by device, type, and ID and places them into 'buffer'.
+  * The file must be opened with the OPEN_READ option. The file read begins at the location of the last read or whatever file offset the special seek option set.
+  * If during the process there is a failure, the actual field indicates how many bytes were transferred and the status will contain a descriptive error code.
+  * parameters :
+  *   j4fs_ctrl->buffer
+  *   j4fs_ctrl->count
+  *   j4fs_ctrl->id
+  *   j4fs_ctrl->index
+  * return
+  *
+  */
+int fsd_read(j4fs_ctrl *ctl)
+{
+	DWORD offset, matching_offset=0xffffffff, len, count, file_length=0xffffffff;
+	int ret=-1;
+	j4fs_header *header;
+	int file_exist=0, i;
+
+#ifdef __KERNEL__
+	BYTE *buf;
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+#else
+	BYTE buf[J4FS_BASIC_UNIT_SIZE];
+#endif
+
+	J4FS_T(J4FS_TRACE_FSD,("%s %d\n",__FUNCTION__,__LINE__));
+
+	for(i=0;i<ro_j4fs_header_count;i++)
+	{
+		header = &ro_j4fs_header[i];
+
+		//This j4fs_header cannot be interpreted.
+		if(header->type!=J4FS_FILE_TYPE)
+		{
+			j4fs_panic("This j4fs_header cannot be interpreted. So this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		// This RO file was deleted and RO file should not be deleted. So this j4fs partition is crashed by some abnormal cause.
+		if((header->flags&0x1)!=((header->flags&0x2)>>1))
+		{
+			j4fs_panic("This RO file was deleted and RO file should not be deleted. So this j4fs partition is crashed by some abnormal cause.  This should be repaired.");
+			goto error1;
+		}
+
+		// File ID is dismatched, so read next file.
+		if(ctl->id && ctl->id!=header->id)
+		{
+			continue;
+		}
+
+		// File ID(inode number) is matched
+		#ifdef __KERNEL__
+		if( ((ctl->index + ctl->count + PAGE_SIZE-1)/PAGE_SIZE*PAGE_SIZE)
+			<= ((header->length + PAGE_SIZE-1)/PAGE_SIZE*PAGE_SIZE) )
+		#else
+		if( ((ctl->index + ctl->count + J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE)
+			<= ((header->length + J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE) )
+		#endif
+		{
+			matching_offset=(i>0)?ro_j4fs_header[i-1].link:device_info.j4fs_offset;
+			file_length=header->length;
+		}
+		else file_exist=1;
+
+		goto got_header;
+
+	}
+
+	if(is_invalid_j4fs_rw_start())
+	{
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error! j4fs_rw_start is invalid(j4fs_rw_start=0x%08x, j4fs_end=0x%08x, ro_j4fs_header_count=0x%08x)\n",
+			__FUNCTION__, __LINE__, j4fs_rw_start, device_info.j4fs_end, ro_j4fs_header_count));
+		j4fs_panic("j4fs_rw_start is invalid");
+		goto error1;
+	}
+
+	// the start address of the RW area of the device (partition)
+	offset=j4fs_rw_start;
+
+	// find object header corresponding to ctl.id in RW area of the device (partition)
+	while(offset!=0xffffffff)
+	{
+		// check the partition range
+		j4fs_check_partition_range(offset);
+
+		// read j4fs_header
+		ret = FlashDevRead(&device_info, offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (error(ret)) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			goto error1;
+		}
+		header=(j4fs_header *)buf;
+
+		//This j4fs_header cannot be interpreted. It means there are no RW files in this partition(this can happen and this is a normal case) or
+		//this j4fs partition is crashed(this should not happen).
+		if(header->type!=J4FS_FILE_TYPE)
+		{
+			// There are no RW files in this partition and this can happen and this is a normal case.
+			if(offset==j4fs_rw_start) {
+				memset(ctl->buffer,0xff,ctl->count);
+				goto error1;
+			}
+
+			// This j4fs partition is crashed by some abnormal cause. This should not happen and should be repaired.
+			j4fs_panic("this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		// This file was deleted, so read next j4fs_header.
+		if((header->flags&0x1)!=((header->flags&0x2)>>1))
+		{
+			offset=header->link;
+			continue;
+		}
+
+		// File ID is dismatched, so read next file.
+		if(ctl->id && ctl->id!=header->id)
+		{
+			offset=header->link;
+			continue;
+		}
+
+		// File ID is matched. we should read lastest object larger than ctl.index, so go ahead.
+		#ifdef __KERNEL__
+		if( ((ctl->index + ctl->count + PAGE_SIZE-1)/PAGE_SIZE*PAGE_SIZE)
+			<= ((header->length + PAGE_SIZE-1)/PAGE_SIZE*PAGE_SIZE) )
+		#else
+		if( ((ctl->index + ctl->count + J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE)
+			<= ((header->length + J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE) )
+		#endif
+		{
+			matching_offset=offset;
+			file_length=header->length;
+		}
+		else file_exist=1;
+
+		offset=header->link;
+	}
+
+got_header:
+
+	//There is valid objects coressponding to ctl->id
+	if(matching_offset!=0xffffffff)
+	{
+		J4FS_T(J4FS_TRACE_FSD,("%s %d\n",__FUNCTION__,__LINE__));
+
+		// We found the wanted file above. Read the data
+		matching_offset+=J4FS_BASIC_UNIT_SIZE;	// j4fs_header takes J4FS_BASIC_UNIT_SIZE
+		matching_offset+=ctl->index;	// consider offset
+		if(ctl->count==0) len=file_length;
+		else len=ctl->count;
+		if(len>file_length) len=file_length;
+		count=0;
+
+		// read data per page size
+		while(len>=device_info.pagesize)
+		{
+			J4FS_T(J4FS_TRACE_FSD,("%s %d: (offset,count,len)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,matching_offset,count,len));
+
+			ret = FlashDevRead(&device_info, matching_offset, device_info.pagesize, ctl->buffer+count);
+
+			if (error(ret)) {
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+			count+=device_info.pagesize;
+			matching_offset+=device_info.pagesize;
+			len-=device_info.pagesize;
+		}
+
+		// read data less than one page and larger than sector
+		if(len>=512)
+		{
+			J4FS_T(J4FS_TRACE_FSD,("%s %d: (offset,count,len)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,matching_offset,count,len));
+
+			ret = FlashDevRead(&device_info, matching_offset, len/512*512, ctl->buffer+count);
+
+			if (error(ret)) {
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+			count+=(len/512*512);
+			matching_offset+=(len/512*512);
+			len-=(len/512*512);
+		}
+
+		// read remained data less than sector size(512Bytes)
+		if(len>0)
+		{
+			J4FS_T(J4FS_TRACE_FSD,("%s %d: (offset,count,len)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,matching_offset,count,len));
+
+			ret = FlashDevRead(&device_info, matching_offset, 512, buf);
+
+			if (error(ret)) {
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+			memcpy(ctl->buffer+count, buf, len);
+			count+=len;
+			len=0;
+		}
+
+	#ifdef __KERNEL__
+		kfree(buf);
+	#endif
+		return count;
+	}
+	else//There is no valid object coressponding to ctl->filename.
+	{
+		memset(ctl->buffer,0xff,ctl->count);
+	#ifdef __KERNEL__
+		kfree(buf);
+	#endif
+		if(file_exist) return ctl->count;
+		return J4FS_NO_FILE;
+	}
+
+error1:
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_FAIL;
+}
+
+/*
+  * This function writes count number of bytes from buffer to the file specified by device, type, and ID. The file must be opened with
+  * the OPEN_CREATE option. If during the process there is a failure, the actual field indicates how many bytes were transferred and the status
+  * will contain a descriptive error code. The file write begins at the location of the last write.
+  * parameters :
+  *   j4fs_ctrl->buffer
+  *   j4fs_ctrl->count
+  *   j4fs_ctrl->id
+  *   j4fs_ctrl->index
+  */
+int fsd_write(j4fs_ctrl *ctl)
+{
+	DWORD offset, last_object_offset=0xffffffff, last_object_length=0xffffffff, matching_latest_object_length=0xffffffff, buffer_index=0, len1, len2;
+	DWORD matching_latest_offset=0xffffffff, new_header_offset=0xffffffff, is_it_last_object=0;
+	j4fs_header *header = 0;
+	int ret=-1;
+
+#ifdef __KERNEL__
+	BYTE *buf;
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+#else
+	BYTE buf[J4FS_BASIC_UNIT_SIZE];
+#endif
+
+#ifdef J4FS_TRANSACTION_LOGGING
+#ifdef __KERNEL__
+	j4fs_transaction *transaction;
+	transaction=kmalloc(J4FS_TRANSACTION_SIZE,GFP_NOFS);
+#else
+	BYTE buf1[J4FS_TRANSACTION_SIZE];
+	j4fs_transaction *transaction=(j4fs_transaction *)buf1;
+#endif
+#endif
+
+	J4FS_T(J4FS_TRACE_FSD,("%s %d: (ino,index)=(%d,0x%08x)\n",__FUNCTION__,__LINE__,ctl->id,ctl->index));
+
+	if(is_invalid_j4fs_rw_start())
+	{
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error! j4fs_rw_start is invalid(j4fs_rw_start=0x%08x, j4fs_end=0x%08x, ro_j4fs_header_count=0x%08x)\n",
+			__FUNCTION__, __LINE__, j4fs_rw_start, device_info.j4fs_end, ro_j4fs_header_count));
+		j4fs_panic("j4fs_rw_start is invalid");
+		goto error1;
+	}
+
+	// parameter checking
+	if(ctl->index < 0)
+	{
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error! ctl->index is invalid(ctl->index=0x%08x)\n",
+			__FUNCTION__, __LINE__, ctl->index));
+		j4fs_panic("ctl->index is invalid");
+		goto error1;
+	}
+
+	if(ctl->count==0)
+	{
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: count is zero\n",__FUNCTION__, __LINE__));
+	#ifdef __KERNEL__
+		kfree(buf);
+	#ifdef J4FS_TRANSACTION_LOGGING
+		kfree(transaction);
+	#endif
+	#endif
+		return J4FS_SUCCESS;
+	}
+
+#ifdef J4FS_TRANSACTION_LOGGING
+	// setting transaction variable
+	memset(transaction,0xff,J4FS_TRANSACTION_SIZE);
+	transaction->count=ctl->count;
+	transaction->index=ctl->index;
+	transaction->magic=J4FS_MAGIC;
+#endif
+
+	// the start address of the RW area of the device (partition)
+	offset=j4fs_rw_start;
+
+	// find space(offset) to write this file. offset follows last enry(last_offset,j4fs_header.link==0xffffffff) in the device
+	while(offset!=0xffffffff)
+	{
+		// check the partition range
+		j4fs_check_partition_range(offset);
+
+		// read j4fs_header
+		ret = FlashDevRead(&device_info, offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (error(ret)) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			goto error1;
+		}
+		header=(j4fs_header *)buf;
+
+		//This j4fs_header cannot be interpreted. It means there are no RW files in this partition(this can happen and this is a normal case) or
+		//this j4fs partition is crashed(this should not happen).
+		if(header->type!=J4FS_FILE_TYPE)
+		{
+			// There are no RW files in this partition or this first j4fs_header is crashed. Before we write data of new file, user of j4fs should write j4fs_header of new file.
+			// So, this case should not happen and/or should be repaired.
+			if(offset==j4fs_rw_start) {
+				j4fs_panic("There are no RW files in this partition or this first RW j4fs_header is crashed. Before we write data of new file, user of j4fs should write j4fs_header of new file. So, this case should not happen and/or should be repaired..");
+				goto error1;
+			}
+
+			// This j4fs partition is crashed by some abnormal cause. This should not happen and should be repaired.
+			j4fs_panic("this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		if(header->link==0xffffffff) last_object_offset=offset;
+
+		// we find ID-matching valid file. Because we should find latest file, go ahead.
+		if((ctl->id==header->id) && ((header->flags&0x1)==((header->flags&0x2)>>1))) matching_latest_offset = offset;
+
+		offset=header->link;
+	}
+
+	// There is no RW files with 'ctl->id' inode number in this partition. Before we write data of new file, user of j4fs should write j4fs_header of new file.
+	if( (matching_latest_offset<j4fs_rw_start) ||(matching_latest_offset>device_info.j4fs_end) ) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: matching_latest_offset is invalid(matching_latest_offset=0x%08x)\n",__FUNCTION__,__LINE__,matching_latest_offset));
+		j4fs_panic("There are no RW files in this partition. Before we write data of new file, user of j4fs should write j4fs_header of new file.");
+		goto error1;
+	}
+
+	// last_object_offset is invalid. last_object_offset should be between j4fs_rw_start and device_info.j4fs_end
+	if( (last_object_offset<j4fs_rw_start) ||(last_object_offset>device_info.j4fs_end) ) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: last_object_offset is invalid(last_object_offset=0x%08x)\n",__FUNCTION__,__LINE__,last_object_offset));
+		j4fs_panic("last_object_offset is invalid. last_object_offset should be between j4fs_rw_start and device_info.j4fs_end");
+		goto error1;
+	}
+
+	if(matching_latest_offset==last_object_offset) is_it_last_object=1;
+	else is_it_last_object=0;
+
+	// when this is a last object in partition (2,3,5,6,8)
+	if(is_it_last_object)
+	{
+		// the length of file which resides at last_object_offset(=matching_latest_offset)
+		matching_latest_object_length=header->length;
+
+		if(matching_latest_object_length < ctl->index)		// j4fs don't support file hole
+		{
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: j4fs don't support file hole(matching_latest_object_length,ctl->index)=(0x%08x,0x%08x)\n",__FUNCTION__,__LINE__,matching_latest_object_length,ctl->index));
+			j4fs_panic("j4fs don't support file hole");
+			goto error1;
+		}
+		else if(matching_latest_object_length == ctl->index)	// when extend file size(2,3,5,6)
+		{
+			buffer_index=0;
+			offset=matching_latest_offset;
+			offset+=J4FS_BASIC_UNIT_SIZE;	// header
+			offset+=ctl->index;				// data
+
+			// check whether we should reclaim
+			if((offset+ctl->count)>device_info.j4fs_end)
+			{
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Reclaim is needed(offset,ctl->count,j4fs_end)=(0x%08x,0x%08x,0x%08x)\n",__FUNCTION__,__LINE__,offset,ctl->count,device_info.j4fs_end));
+				ret=fsd_reclaim();
+
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+			#ifdef __KERNEL__
+				kfree(buf);
+			#endif
+				return J4FS_RETRY_WRITE;
+			}
+
+			// write first J4FS_BASIC_UNIT_SIZE-not-aligned data to Storage
+			if(ctl->index % J4FS_BASIC_UNIT_SIZE)
+			{
+				len1 = ctl->index % J4FS_BASIC_UNIT_SIZE;
+				len2=J4FS_BASIC_UNIT_SIZE-len1;
+				if(len2 > ctl->count) len2=ctl->count;
+
+				// read len1'length' data from Stroage
+				ret = FlashDevRead(&device_info, offset-len1, (len1+511)/512*512, buf);
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				memcpy(buf+len1, ctl->buffer, len2);
+
+				// write (len1+len2)'length' data to Stroage
+				ret = FlashDevWrite(&device_info, offset-len1, (len1+len2+511)/512*512, buf);
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				buffer_index += len2;
+				offset += len2;
+				ctl->count -= len2;
+			}
+
+			// write data per page size
+			while(ctl->count>=device_info.pagesize)
+			{
+				ret = FlashDevWrite(&device_info, offset, device_info.pagesize, ctl->buffer+buffer_index);
+
+				J4FS_T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				buffer_index+=device_info.pagesize;
+				offset+=device_info.pagesize;
+				ctl->count-=device_info.pagesize;
+			}
+
+			// write data less than one page and larger than sector
+			if(ctl->count>=512)
+			{
+				ret = FlashDevWrite(&device_info, offset, ctl->count/512*512, ctl->buffer+buffer_index);
+
+				J4FS_T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				buffer_index+=(ctl->count/512*512);
+				offset+=(ctl->count/512*512);
+				ctl->count-=(ctl->count/512*512);
+			}
+
+			// write remained data less than sector size(512Bytes)
+			if(ctl->count>0)
+			{
+				memcpy(buf, ctl->buffer+buffer_index, ctl->count);
+				ret = FlashDevWrite(&device_info, offset, 512, buf);
+
+				J4FS_T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				buffer_index+=ctl->count;
+				offset+=ctl->count;
+				ctl->count=0;
+			}
+
+			// update existing j4fs_header to extend file size
+			// read j4fs_header
+			ret = FlashDevRead(&device_info, matching_latest_offset, J4FS_BASIC_UNIT_SIZE, buf);
+			if (error(ret)) {
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+			header=(j4fs_header *)buf;
+
+		#ifdef J4FS_TRANSACTION_LOGGING
+			// setting transaction variable
+			transaction->sequence=j4fs_next_sequence++;
+			transaction->ino=header->id;
+			strcpy(transaction->filename,header->filename);
+			transaction->opcode=J4FS_LAST_OBJECT_WRITE_EXTEND1;
+			transaction->offset=matching_latest_offset;
+			transaction->b_link=transaction->a_link=header->link;
+			transaction->b_length=header->length;
+			transaction->a_length=header->length+buffer_index;
+
+			ret = FlashDevWrite(&device_info, j4fs_transaction_next_offset, J4FS_TRANSACTION_SIZE, (BYTE *)transaction);
+
+			if (error(ret)) {
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+			j4fs_transaction_next_offset+=J4FS_TRANSACTION_SIZE;
+			if(j4fs_transaction_next_offset>=device_info.j4fs_device_end) j4fs_transaction_next_offset=device_info.j4fs_end;
+		#endif
+
+			// update file length
+			header->length += buffer_index;
+
+			ret = FlashDevWrite(&device_info, matching_latest_offset, J4FS_BASIC_UNIT_SIZE, buf);
+
+			if (error(ret)) {
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+			goto done;
+		}
+		else if(matching_latest_object_length > ctl->index)	// when update existing data(8)
+		{
+			buffer_index=0;
+			offset=matching_latest_offset;
+			offset+=J4FS_BASIC_UNIT_SIZE;	// header
+			offset+=ctl->index;				// data
+
+			// check whether we should reclaim
+			if((offset+ctl->count)>device_info.j4fs_end)
+			{
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Reclaim is needed(offset,ctl->count,j4fs_end)=(0x%08x,0x%08x,0x%08x)\n",__FUNCTION__,__LINE__,offset,ctl->count,device_info.j4fs_end));
+				ret=fsd_reclaim();
+
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+			#ifdef __KERNEL__
+				kfree(buf);
+			#ifdef J4FS_TRANSACTION_LOGGING
+				kfree(transaction);
+			#endif
+			#endif
+				return J4FS_RETRY_WRITE;
+			}
+
+			// write first J4FS_BASIC_UNIT_SIZE-not-aligned data to Storage
+			if(ctl->index % J4FS_BASIC_UNIT_SIZE)
+			{
+				len1 = ctl->index % J4FS_BASIC_UNIT_SIZE;
+				len2=J4FS_BASIC_UNIT_SIZE-len1;
+				if(len2 > ctl->count) len2=ctl->count;
+
+				// read len1'length' data from Stroage
+				ret = FlashDevRead(&device_info, offset-len1, (len1+511)/512*512, buf);
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				memcpy(buf+len1, ctl->buffer, len2);
+
+				// write (len1+len2)'length' data to Stroage
+				ret = FlashDevWrite(&device_info, offset-len1, (len1+len2+511)/512*512, buf);
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				buffer_index += len2;
+				offset += len2;
+				ctl->count -= len2;
+			}
+
+			// write data per page size
+			while(ctl->count>=device_info.pagesize)
+			{
+				ret = FlashDevWrite(&device_info, offset, device_info.pagesize, ctl->buffer+buffer_index);
+
+				J4FS_T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				buffer_index+=device_info.pagesize;
+				offset+=device_info.pagesize;
+				ctl->count-=device_info.pagesize;
+			}
+
+			// write data less than one page and larger than sector
+			if(ctl->count>=512)
+			{
+				ret = FlashDevWrite(&device_info, offset, ctl->count/512*512, ctl->buffer+buffer_index);
+
+				J4FS_T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				buffer_index+=(ctl->count/512*512);
+				offset+=(ctl->count/512*512);
+				ctl->count-=(ctl->count/512*512);
+			}
+
+			// write remained data less than sector size(512Bytes)
+			if(ctl->count>0)
+			{
+				// read 512B'length' data from Stroage
+				ret = FlashDevRead(&device_info, offset, 512, buf);
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				memcpy(buf, ctl->buffer+buffer_index, ctl->count);
+				ret = FlashDevWrite(&device_info, offset, 512, buf);
+
+				J4FS_T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				buffer_index+=ctl->count;
+				offset+=ctl->count;
+				ctl->count=0;
+			}
+
+			// update existing j4fs_header to update file size if needed
+			if((offset-matching_latest_offset-J4FS_BASIC_UNIT_SIZE) > matching_latest_object_length)
+			{
+				// read j4fs_header
+				ret = FlashDevRead(&device_info, matching_latest_offset, J4FS_BASIC_UNIT_SIZE, buf);
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				header=(j4fs_header *)buf;
+
+			#ifdef J4FS_TRANSACTION_LOGGING
+				// setting transaction variable
+				transaction->sequence=j4fs_next_sequence++;
+				transaction->ino=header->id;
+				strcpy(transaction->filename,header->filename);
+				transaction->opcode=J4FS_LAST_OBJECT_WRITE_EXTEND2;
+				transaction->offset=matching_latest_offset;
+				transaction->b_link=transaction->a_link=header->link;
+				transaction->b_length=header->length;
+				transaction->a_length=offset-matching_latest_offset-J4FS_BASIC_UNIT_SIZE;
+
+				ret = FlashDevWrite(&device_info, j4fs_transaction_next_offset, J4FS_TRANSACTION_SIZE, (BYTE *)transaction);
+
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				j4fs_transaction_next_offset+=J4FS_TRANSACTION_SIZE;
+				if(j4fs_transaction_next_offset>=device_info.j4fs_device_end) j4fs_transaction_next_offset=device_info.j4fs_end;
+			#endif
+
+				header->length = offset-matching_latest_offset-J4FS_BASIC_UNIT_SIZE;
+				ret = FlashDevWrite(&device_info, matching_latest_offset, J4FS_BASIC_UNIT_SIZE, buf);
+
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+			}
+			goto done;
+		}
+		else
+		{
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: we should not come here\n",__FUNCTION__,__LINE__));
+			j4fs_panic("we should not come here");
+			goto error1;
+		}
+	}
+	else if(!is_it_last_object)
+	{
+		// the length of file which resides at last_object_offset
+		last_object_length = header->length;
+
+		// read j4fs_header
+		ret = FlashDevRead(&device_info, matching_latest_offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (error(ret)) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			goto error1;
+		}
+		header=(j4fs_header *)buf;
+		matching_latest_object_length=header->length;
+
+		if(matching_latest_object_length < ctl->index)		// j4fs don't support file hole
+		{
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: j4fs don't support file hole(matching_latest_object_length,ctl->index)=(0x%08x,0x%08x)\n",__FUNCTION__,__LINE__,matching_latest_object_length,ctl->index));
+			j4fs_panic("j4fs don't support file hole");
+			goto error1;
+		}
+		else if(matching_latest_object_length >= (ctl->index+ctl->count))	// update not-last object in partition and No extension(7)
+		{
+			buffer_index=0;
+			offset=matching_latest_offset;
+			offset+=J4FS_BASIC_UNIT_SIZE;	// header
+			offset+=ctl->index;				// data
+
+			// check whether we should reclaim
+			if((offset+ctl->count)>device_info.j4fs_end)
+			{
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: This case should not happen(offset,ctl->count,j4fs_end)=(0x%08x,0x%08x,0x%08x)\n",__FUNCTION__,__LINE__,offset,ctl->count,device_info.j4fs_end));
+				j4fs_panic("This case should not happen");
+				goto error1;
+			}
+
+			// write first J4FS_BASIC_UNIT_SIZE-not-aligned data to Storage
+			if(ctl->index % J4FS_BASIC_UNIT_SIZE)
+			{
+				len1 = ctl->index % J4FS_BASIC_UNIT_SIZE;
+				len2=J4FS_BASIC_UNIT_SIZE-len1;
+				if(len2 > ctl->count) len2=ctl->count;
+
+				// read len1'length' data from Stroage
+				ret = FlashDevRead(&device_info, offset-len1, (len1+511)/512*512, buf);
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				memcpy(buf+len1, ctl->buffer, len2);
+
+				// write (len1+len2)'length' data to Stroage
+				ret = FlashDevWrite(&device_info, offset-len1, (len1+len2+511)/512*512, buf);
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				buffer_index += len2;
+				offset += len2;
+				ctl->count -= len2;
+			}
+
+			// write data per page size
+			while(ctl->count>=device_info.pagesize)
+			{
+				ret = FlashDevWrite(&device_info, offset, device_info.pagesize, ctl->buffer+buffer_index);
+
+				J4FS_T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				buffer_index+=device_info.pagesize;
+				offset+=device_info.pagesize;
+				ctl->count-=device_info.pagesize;
+			}
+
+			// write data less than one page and larger than sector
+			if(ctl->count>=512)
+			{
+				ret = FlashDevWrite(&device_info, offset, ctl->count/512*512, ctl->buffer+buffer_index);
+
+				J4FS_T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				buffer_index+=(ctl->count/512*512);
+				offset+=(ctl->count/512*512);
+				ctl->count-=(ctl->count/512*512);
+			}
+
+			// write remained data less than sector size(512Bytes)
+			if(ctl->count>0)
+			{
+				J4FS_T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				// read 512B'length' data from Stroage
+				ret = FlashDevRead(&device_info, offset, 512, buf);
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				memcpy(buf, ctl->buffer+buffer_index, ctl->count);
+				ret = FlashDevWrite(&device_info, offset, 512, buf);
+
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				buffer_index+=ctl->count;
+				offset+=ctl->count;
+				ctl->count=0;
+			}
+
+			goto done;
+		}
+		else if(matching_latest_object_length < (ctl->index+ctl->count))	// update not-last object in partition and file size is extended(9,11,12,13)
+		{
+			new_header_offset=last_object_offset;
+			new_header_offset+=J4FS_BASIC_UNIT_SIZE;	// header
+			new_header_offset+=last_object_length;			// data
+			new_header_offset=(new_header_offset+J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE;	// J4FS_BASIC_UNIT_SIZE Align
+
+			// copy existing 'all data' of 'matching_latest_offset' offset to 'new_header_offset' offset
+			len1=matching_latest_object_length;
+			len1=(len1+J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE;	// J4FS_BASIC_UNIT_SIZE Align
+			buffer_index=J4FS_BASIC_UNIT_SIZE;
+
+			// write data per J4FS_BASIC_UNIT_SIZE size
+			while(len1>=J4FS_BASIC_UNIT_SIZE)
+			{
+				J4FS_T(J4FS_TRACE_FSD,("%s %d: (matching_latest_offset,new_header_offset,buffer_index)=(0x%08x,0x%08x,0x%08x)\n",
+					__FUNCTION__,__LINE__,matching_latest_offset,new_header_offset,buffer_index));
+
+				ret = FlashDevRead(&device_info, matching_latest_offset+buffer_index, J4FS_BASIC_UNIT_SIZE, buf);
+
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				ret = FlashDevWrite(&device_info, new_header_offset+buffer_index, J4FS_BASIC_UNIT_SIZE, buf);
+
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				buffer_index+=J4FS_BASIC_UNIT_SIZE;
+				len1-=J4FS_BASIC_UNIT_SIZE;
+			}
+
+			if(len1!=0)
+			{
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: This case should not happen(len1)=(0x%08x)\n",__FUNCTION__,__LINE__,len1));
+				j4fs_panic("This case should not happen");
+				goto error1;
+			}
+
+			// copy existing j4fs_header of 'matching_latest_offset' offset to 'new_header_offset' offset
+			J4FS_T(J4FS_TRACE_FSD,("%s %d: (matching_latest_offset,new_header_offset)=(0x%08x,0x%08x)\n", __FUNCTION__,__LINE__,matching_latest_offset,new_header_offset));
+			ret = FlashDevRead(&device_info, matching_latest_offset, J4FS_BASIC_UNIT_SIZE, buf);
+			if (error(ret)) {
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+			header=(j4fs_header *)buf;
+
+		#ifdef J4FS_TRANSACTION_LOGGING
+			// setting transaction variable
+			transaction->sequence=j4fs_next_sequence++;
+			transaction->ino=header->id;
+			strcpy(transaction->filename,header->filename);
+			transaction->opcode=J4FS_NOLAST_OBJECT_WRITE_EXTEND_STEP1;
+			transaction->offset=new_header_offset;
+			transaction->b_link=header->link;
+			transaction->a_link=0xffffffff;
+			transaction->b_length=transaction->a_length=header->length;
+
+			ret = FlashDevWrite(&device_info, j4fs_transaction_next_offset, J4FS_TRANSACTION_SIZE, (BYTE *)transaction);
+
+			if (error(ret)) {
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+			j4fs_transaction_next_offset+=J4FS_TRANSACTION_SIZE;
+			if(j4fs_transaction_next_offset>=device_info.j4fs_device_end) j4fs_transaction_next_offset=device_info.j4fs_end;
+		#endif
+
+			header->link=0xffffffff;
+
+			ret = FlashDevWrite(&device_info, new_header_offset, J4FS_BASIC_UNIT_SIZE, buf);
+			if (error(ret)) {
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+			// update the link of last_object_offset to indicate new_header_offset
+			// read j4fs_header
+			ret = FlashDevRead(&device_info, last_object_offset, J4FS_BASIC_UNIT_SIZE, buf);
+			if (error(ret)) {
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+			header=(j4fs_header *)buf;
+
+		#ifdef J4FS_TRANSACTION_LOGGING
+			// setting transaction variable
+			transaction->sequence=j4fs_next_sequence++;
+			transaction->ino=header->id;
+			strcpy(transaction->filename,header->filename);
+			transaction->opcode=J4FS_NOLAST_OBJECT_WRITE_EXTEND_STEP2;
+			transaction->offset=last_object_offset;
+			transaction->b_link=header->link;
+			transaction->a_link=new_header_offset;
+			transaction->b_length=transaction->a_length=header->length;
+
+			ret = FlashDevWrite(&device_info, j4fs_transaction_next_offset, J4FS_TRANSACTION_SIZE, (BYTE *)transaction);
+
+			if (error(ret)) {
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+			j4fs_transaction_next_offset+=J4FS_TRANSACTION_SIZE;
+			if(j4fs_transaction_next_offset>=device_info.j4fs_device_end) j4fs_transaction_next_offset=device_info.j4fs_end;
+		#endif
+
+			header->link= new_header_offset;
+			ret = FlashDevWrite(&device_info, last_object_offset, J4FS_BASIC_UNIT_SIZE, buf);
+
+			if (error(ret)) {
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+			// write new data(file size is extended)
+			buffer_index=0;
+			offset=new_header_offset;
+			offset+=J4FS_BASIC_UNIT_SIZE;	// header
+			offset+=ctl->index;				// data
+
+			// check whether we should reclaim
+			if((offset+ctl->count)>device_info.j4fs_end)
+			{
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Reclaim is needed(offset,ctl->count,j4fs_end)=(0x%08x,0x%08x,0x%08x)\n",__FUNCTION__,__LINE__,offset,ctl->count,device_info.j4fs_end));
+				ret=fsd_reclaim();
+
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+			#ifdef __KERNEL__
+				kfree(buf);
+			#endif
+				return J4FS_RETRY_WRITE;
+			}
+
+			// write first J4FS_BASIC_UNIT_SIZE-not-aligned data to Storage
+			if(ctl->index % J4FS_BASIC_UNIT_SIZE)
+			{
+				len1=ctl->index % J4FS_BASIC_UNIT_SIZE;
+				len2=J4FS_BASIC_UNIT_SIZE-len1;
+				if(len2 > ctl->count) len2=ctl->count;
+
+				// read len1'length' data from Stroage
+				ret = FlashDevRead(&device_info, offset-len1, (len1+511)/512*512, buf);
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				memcpy(buf+len1, ctl->buffer, len2);
+
+				// write (len1+len2)'length' data to Stroage
+				ret = FlashDevWrite(&device_info, offset-len1, (len1+len2+511)/512*512, buf);
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				buffer_index += len2;
+				offset += len2;
+				ctl->count -= len2;
+			}
+
+			// write data per page size
+			while(ctl->count>=device_info.pagesize)
+			{
+				ret = FlashDevWrite(&device_info, offset, device_info.pagesize, ctl->buffer+buffer_index);
+
+				J4FS_T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				buffer_index+=device_info.pagesize;
+				offset+=device_info.pagesize;
+				ctl->count-=device_info.pagesize;
+			}
+
+			// write data less than one page and larger than sector
+			if(ctl->count>=512)
+			{
+				ret = FlashDevWrite(&device_info, offset, ctl->count/512*512, ctl->buffer+buffer_index);
+
+				J4FS_T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				buffer_index+=(ctl->count/512*512);
+				offset+=(ctl->count/512*512);
+				ctl->count-=(ctl->count/512*512);
+			}
+
+			// write remained data less than sector size(512Bytes)
+			if(ctl->count>0)
+			{
+				memcpy(buf, ctl->buffer+buffer_index, ctl->count);
+				ret = FlashDevWrite(&device_info, offset, 512, buf);
+
+				J4FS_T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				buffer_index+=ctl->count;
+				offset+=ctl->count;
+				ctl->count=0;
+			}
+
+			// update new_header_offset to update file size extension
+			// read j4fs_header
+			ret = FlashDevRead(&device_info, new_header_offset, J4FS_BASIC_UNIT_SIZE, buf);
+			if (error(ret)) {
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+			header=(j4fs_header *)buf;
+
+		#ifdef J4FS_TRANSACTION_LOGGING
+			// setting transaction variable
+			transaction->sequence=j4fs_next_sequence++;
+			transaction->ino=header->id;
+			strcpy(transaction->filename,header->filename);
+			transaction->opcode=J4FS_NOLAST_OBJECT_WRITE_EXTEND_STEP3;
+			transaction->offset=new_header_offset;
+			transaction->b_link=transaction->a_link=header->link;
+			transaction->b_length=header->length;
+			transaction->a_length=offset-new_header_offset-J4FS_BASIC_UNIT_SIZE;
+
+			ret = FlashDevWrite(&device_info, j4fs_transaction_next_offset, J4FS_TRANSACTION_SIZE, (BYTE *)transaction);
+
+			if (error(ret)) {
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+			j4fs_transaction_next_offset+=J4FS_TRANSACTION_SIZE;
+			if(j4fs_transaction_next_offset>=device_info.j4fs_device_end) j4fs_transaction_next_offset=device_info.j4fs_end;
+		#endif
+
+			header->length = offset-new_header_offset-J4FS_BASIC_UNIT_SIZE;
+			ret = FlashDevWrite(&device_info, new_header_offset, J4FS_BASIC_UNIT_SIZE, buf);
+
+			if (error(ret)) {
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+			goto done;
+		}
+		else
+		{
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: we should not come here\n",__FUNCTION__,__LINE__));
+			j4fs_panic("we should not come here");
+			goto error1;
+		}
+	}
+	else
+	{
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: we should not come here\n",__FUNCTION__,__LINE__));
+		j4fs_panic("we should not come here");
+		goto error1;
+	}
+
+done:
+	J4FS_T(J4FS_TRACE_FSD,("%s %d: write completed(written=%d)\n",__FUNCTION__,__LINE__,buffer_index));
+
+	fsd_print_meta_data();
+
+#ifdef __KERNEL__
+	kfree(buf);
+#ifdef J4FS_TRANSACTION_LOGGING
+	kfree(transaction);
+#endif
+#endif
+	return buffer_index;
+
+error1:
+#ifdef __KERNEL__
+	kfree(buf);
+#ifdef J4FS_TRANSACTION_LOGGING
+	kfree(transaction);
+#endif
+#endif
+	return J4FS_FAIL;
+}
+
+int fsd_unlink(char *filename)
+{
+	DWORD offset;
+	j4fs_header *header;
+	int ret=-1;
+
+#ifdef __KERNEL__
+	BYTE *buf;
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+#else
+	BYTE buf[J4FS_BASIC_UNIT_SIZE];
+#endif
+
+	if(filename==NULL) {
+	#ifdef __KERNEL__
+		kfree(buf);
+	#endif
+		return 0;
+	}
+
+	if(is_invalid_j4fs_rw_start())
+	{
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error! j4fs_rw_start is invalid(j4fs_rw_start=0x%08x, j4fs_end=0x%08x, ro_j4fs_header_count=0x%08x)\n",
+			__FUNCTION__, __LINE__, j4fs_rw_start, device_info.j4fs_end, ro_j4fs_header_count));
+		j4fs_panic("j4fs_rw_start is invalid");
+		goto error1;
+	}
+
+	// the start address of the RW area of the device (partition)
+	offset=j4fs_rw_start;
+
+	// find object header corresponding to filename
+	while(offset!=0xffffffff)
+	{
+		// read j4fs_header
+		ret = FlashDevRead(&device_info, offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (error(ret)) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			goto error1;
+		}
+		header=(j4fs_header *)buf;
+
+		//This j4fs_header cannot be interpreted. It means there are no RW files in this partition(this can happen and this is a normal case) or
+		//this j4fs partition is crashed(this should not happen).
+		if(header->type!=J4FS_FILE_TYPE)
+		{
+			// There are no RW files in this partition or this first j4fs_header is crashed. Before we write data of new file, user of j4fs should write j4fs_header of new file.
+			// So, this case should not happen and/or should be repaired.
+			if(offset==j4fs_rw_start) {
+				j4fs_panic("There are no RW files in this partition or this first RW j4fs_header is crashed. Before we write data of new file, user of j4fs should write j4fs_header of new file. So, this case should not happen and/or should be repaired..");
+				goto error1;
+			}
+
+			// This j4fs partition is crashed by some abnormal cause. This should not happen and should be repaired.
+			j4fs_panic("this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		// This file was deleted, so read next j4fs_header.
+		if((header->flags&0x1)!=((header->flags&0x2)>>1))
+		{
+			offset=header->link;
+			continue;
+		}
+
+		// filename is dismatched, so read next file.
+		if(strcmp(filename,header->filename))
+		{
+			offset=header->link;
+			continue;
+		}
+
+		// this file will be deleted
+		header->flags=0x1;
+
+		ret = FlashDevWrite(&device_info, offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (error(ret)) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+	   		goto error1;
+		}
+
+		offset=header->link;
+	}
+
+	ret=fsd_reclaim();
+
+	if (error(ret)) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+		goto error1;
+	}
+
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return 0;
+
+error1:
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_FAIL;
+}
+
+/*
+  * This function will reclaim all unused space on the device specified. Reclaim removes file objects that have been marked deleted and
+  * relocates valid file objects to create the maximum contiguous free space
+  */
+int fsd_reclaim()
+{
+	DWORD offset, rw_start;
+	j4fs_mst *mst;
+	j4fs_header *header;
+	int i;
+	int ret=-1;
+	int first_unused_area_offset=0xffffffff;
+
+#ifdef __KERNEL__
+	BYTE *buf_mst, *buf_header, *buf_data;
+	buf_mst=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+	buf_header=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+	buf_data=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+#else
+	BYTE buf_mst[J4FS_BASIC_UNIT_SIZE], buf_header[J4FS_BASIC_UNIT_SIZE], buf_data[J4FS_BASIC_UNIT_SIZE];
+#endif
+
+
+#ifdef J4FS_TRANSACTION_LOGGING
+#ifdef __KERNEL__
+	j4fs_transaction *transaction;
+	transaction=kmalloc(J4FS_TRANSACTION_SIZE,GFP_NOFS);
+#else
+	BYTE buf[J4FS_TRANSACTION_SIZE];
+	j4fs_transaction *transaction=(j4fs_transaction *)buf;
+#endif
+#endif
+
+	header=(j4fs_header *)buf_header;
+	mst=(j4fs_mst *)buf_mst;
+
+	// read mst
+	ret = FlashDevRead(&device_info, 0, J4FS_BASIC_UNIT_SIZE, buf_mst);
+	if (error(ret)) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+   		goto error1;
+	}
+
+	// If MST is not recognized, Initialize MST
+	if(mst->magic!=J4FS_MAGIC)
+	{
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: MST is not recognized(mst.magic=0x%08x)\n",__FUNCTION__,__LINE__,mst->magic));
+		j4fs_panic("MST is not recognized");
+		goto error1;
+	}
+
+	if((mst->status|J4FS_PANIC_MASK)==J4FS_PANIC)
+	{
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: j4fs is crashed(mst.status=0x%08x)\n",__FUNCTION__,__LINE__,mst->status));
+		j4fs_panic("j4fs is crashed");
+   		goto error1;
+	}
+
+	J4FS_T(J4FS_TRACE_FSD_RECLAIM,("\n%s %d: Reclaim Starts\n",__FUNCTION__,__LINE__));
+	fsd_print_meta_data();
+
+	// If reclaim is in progress(sudden power-off in progress of reclaim), restart reclaim. This is power-off-recovery(POR)!!!
+	if(mst->status&J4FS_RECLAIM_MOVING_DATA_STEP_1) goto moving_data_step_1;
+	if(mst->status&J4FS_RECLAIM_MOVING_DATA_STEP_2) goto moving_data_step_2;
+	if(mst->status&J4FS_RECLAIM_UPDATE_LINK) goto update_link;
+
+	/**************************************************************************
+	 * This is first reclaim since last reclaim is done successfully(There are no power off in the middle of reclaim)
+	 **************************************************************************/
+
+	if(!mst->rw_start ||(mst->rw_start>= device_info.j4fs_end))
+	{
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error! rw_start is invalid(j4fs_rw_start=0x%08x, j4fs_end=0x%08x)\n", __FUNCTION__, __LINE__, mst->rw_start, device_info.j4fs_end));
+		j4fs_panic("rw_start is invalid");
+		goto error1;
+	}
+
+	// invalidate old valid files
+	fsd_mark_invalid();
+
+	// the start address of the RW area of the device (partition)
+	offset=mst->rw_start;
+
+	while(offset!=0xffffffff)
+	{
+		// read j4fs_header
+		ret = FlashDevRead(&device_info, offset, J4FS_BASIC_UNIT_SIZE, buf_header);
+		if (error(ret)) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+	   		goto error1;
+		}
+
+		//This j4fs_header cannot be interpreted. We have scaned all objects in device(partition)
+		if(header->type!=J4FS_FILE_TYPE) break;
+
+		// This file is invalid(deleted)
+		if((header->flags&0x1)!=((header->flags&0x2)>>1))
+		{
+			if(mst->to==0) mst->to=offset;
+			offset=header->link;
+			continue;
+		}
+		// This file is valid(not deleted, reclaim may start)
+		else
+		{
+			// If this object is first object, just skip it
+			if(offset==device_info.j4fs_offset)
+			{
+				offset=header->link;
+				continue;
+			}
+
+			// If invalid object is not scanned yet, there are no place to copy this valid object
+			if(mst->to==0)
+			{
+				offset=header->link;
+				continue;
+			}
+
+			/**************************************************************************
+			 * Start to copy this valid object to invalid area(to offset)
+			 **************************************************************************/
+			mst->from=offset;
+			offset += J4FS_BASIC_UNIT_SIZE;	// header
+			offset += header->length;	// data
+			offset = (offset+J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE;	// J4FS_BASIC_UNIT_SIZE align. offset indicate 'end of this object and beginning of next object'
+			mst->end=offset;
+			mst->copyed=0;
+			mst->status=J4FS_RECLAIM_MOVING_DATA_STEP_1;
+
+			if(header->link==0xffffffff) mst->status|=J4FS_RECLAIM_LAST_OBJECT;
+
+			POR(0x1,("%s %d: Power-off point-1\n",__FUNCTION__,__LINE__),2000);
+
+			// write mst reflected new status(from,end)
+			ret = FlashDevWrite(&device_info, 0, J4FS_BASIC_UNIT_SIZE, buf_mst);
+			if (error(ret)) {
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+		   		goto error1;
+			}
+
+moving_data_step_1:
+
+			POR(0x2,("%s %d: Power-off point-2\n",__FUNCTION__,__LINE__),2000);
+
+			// copy valid data('from' offset) to invalid area('to' offset)
+			while(mst->from < mst->end)
+			{
+				POR(0x4,("%s %d: Power-off point-4\n",__FUNCTION__,__LINE__),2000);
+
+				// read valid data
+				ret = FlashDevRead(&device_info, mst->from, J4FS_BASIC_UNIT_SIZE, buf_data);
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			   		goto error1;
+				}
+
+				POR(0x8,("%s %d: Power-off point-8\n",__FUNCTION__,__LINE__),2000);
+
+				// write valid data
+				ret = FlashDevWrite(&device_info, mst->to, J4FS_BASIC_UNIT_SIZE, buf_data);
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			   		goto error1;
+				}
+
+				POR(0x10,("%s %d: Power-off point-10\n",__FUNCTION__,__LINE__),2000);
+
+				// write updated MST status(from,to)
+				mst->from+=J4FS_BASIC_UNIT_SIZE;
+				mst->to+=J4FS_BASIC_UNIT_SIZE;
+				mst->copyed+=J4FS_BASIC_UNIT_SIZE;
+				ret = FlashDevWrite(&device_info, 0, J4FS_BASIC_UNIT_SIZE, buf_mst);
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			   		goto error1;
+				}
+
+				POR(0x20,("%s %d: Power-off point-20\n",__FUNCTION__,__LINE__),2000);
+
+			}
+
+			POR(0x40,("%s %d: Power-off point-40\n",__FUNCTION__,__LINE__),2000);
+
+			// write updated MST status(offset,offset_number,from,to)
+			mst->offset[mst->offset_number]=mst->to-mst->copyed;
+			mst->offset_number++;
+			mst->status= (mst->status&J4FS_RECLAIM_LAST_OBJECT)|J4FS_RECLAIM_MOVING_DATA_STEP_2;
+			ret = FlashDevWrite(&device_info, 0, J4FS_BASIC_UNIT_SIZE, buf_mst);
+			if (error(ret)) {
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+		   		goto error1;
+			}
+
+moving_data_step_2:
+			if(mst->status&J4FS_RECLAIM_LAST_OBJECT) offset=0xffffffff;
+			else offset=mst->end;
+
+			POR(0x80,("%s %d: Power-off point-80\n",__FUNCTION__,__LINE__),2000);
+
+			/**************************************************************************
+			 * End of copying this valid object to invalid area(to offset)
+			 **************************************************************************/
+		}
+	}
+
+	POR(0x100,("%s %d: Power-off point-100\n",__FUNCTION__,__LINE__),2000);
+
+	if(mst->offset_number==0) goto reclaim_done;
+
+	// Adjust j4fs_header.link of valid object
+	// write updated MST status(status)
+	mst->status=J4FS_RECLAIM_UPDATE_LINK;
+	ret = FlashDevWrite(&device_info, 0, J4FS_BASIC_UNIT_SIZE, buf_mst);
+	if (error(ret)) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+   		goto error1;
+	}
+
+update_link:
+
+	POR(0x200,("%s %d: Power-off point-200\n",__FUNCTION__,__LINE__),2000);
+
+	// Adjust j4fs_header.link of valid objects excluding last object
+	if(mst->offset_number>=2)
+	{
+		for(i=0;i<mst->offset_number-1;i++)
+		{
+			POR(0x400,("%s %d: Power-off point-400\n",__FUNCTION__,__LINE__),2000);
+
+			// read j4fs_header
+			ret = FlashDevRead(&device_info, mst->offset[i], J4FS_BASIC_UNIT_SIZE, buf_header);
+			if (error(ret)) {
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+		   		goto error1;
+			}
+
+			POR(0x800,("%s %d: Power-off point-800\n",__FUNCTION__,__LINE__),2000);
+
+			header->link=mst->offset[i+1];
+
+			// write j4fs_header
+			ret = FlashDevWrite(&device_info, mst->offset[i], J4FS_BASIC_UNIT_SIZE, buf_header);
+			if (error(ret)) {
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+		   		goto error1;
+			}
+
+			POR(0x1000,("%s %d: Power-off point-1000\n",__FUNCTION__,__LINE__),2000);
+
+		}
+	}
+
+	POR(0x2000,("%s %d: Power-off point-2000\n",__FUNCTION__,__LINE__),2000);
+
+	// Adjust j4fs_header.link of last valid object
+	if(mst->offset_number>0)
+	{
+		POR(0x4000,("%s %d: Power-off point-4000\n",__FUNCTION__,__LINE__),2000);
+
+		// read j4fs_header
+		ret = FlashDevRead(&device_info, mst->offset[mst->offset_number-1], J4FS_BASIC_UNIT_SIZE, buf_header);
+		if (error(ret)) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+	   		goto error1;
+		}
+
+		POR(0x8000,("%s %d: Power-off point-8000\n",__FUNCTION__,__LINE__),2000);
+
+		header->link=0xffffffff;
+
+		// write j4fs_header
+		ret = FlashDevWrite(&device_info, mst->offset[mst->offset_number-1], J4FS_BASIC_UNIT_SIZE, buf_header);
+		if (error(ret)) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+	   		goto error1;
+		}
+
+		POR(0x10000,("%s %d: Power-off point-10000\n",__FUNCTION__,__LINE__),2000);
+
+		first_unused_area_offset = mst->offset[mst->offset_number-1] + J4FS_BASIC_UNIT_SIZE + header->length;
+		first_unused_area_offset = (first_unused_area_offset + J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE;
+
+	}
+
+	POR(0x20000,("%s %d: Power-off point-20000\n",__FUNCTION__,__LINE__),2000);
+
+	// write 'Reclaim Done'
+	rw_start=mst->rw_start;
+	memset(mst,0x0,J4FS_BASIC_UNIT_SIZE);
+	mst->magic=J4FS_MAGIC;
+	mst->status=J4FS_RECLAIM_DONE;
+	mst->rw_start=rw_start;
+
+#ifdef J4FS_TRANSACTION_LOGGING
+	// setting transaction variable
+	memset(transaction,0xff,J4FS_TRANSACTION_SIZE);
+	transaction->magic=J4FS_MAGIC;
+	transaction->sequence=j4fs_next_sequence++;
+	transaction->opcode=J4FS_RECLAIM_STEP2;
+
+	ret = FlashDevWrite(&device_info, j4fs_transaction_next_offset, J4FS_TRANSACTION_SIZE, (BYTE *)transaction);
+
+	if (error(ret)) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+		goto error1;
+	}
+
+	j4fs_transaction_next_offset+=J4FS_TRANSACTION_SIZE;
+	if(j4fs_transaction_next_offset>=device_info.j4fs_device_end) j4fs_transaction_next_offset=device_info.j4fs_end;
+#endif
+
+	ret = FlashDevWrite(&device_info, 0, J4FS_BASIC_UNIT_SIZE, buf_mst);
+	if (error(ret)) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+   		goto error1;
+	}
+
+#ifdef J4FS_RECLAIM_RESET_UNUSED_SPACE
+	// Set 'not used space' to 0xff. This is not mandatory
+	if(first_unused_area_offset!=0xffffffff)
+	{
+		memset(buf_data,0xff,J4FS_BASIC_UNIT_SIZE);
+		for(i=0; i<10*J4FS_BASIC_UNIT_SIZE; i+=J4FS_BASIC_UNIT_SIZE)
+		{
+			J4FS_T(J4FS_TRACE_FSD_RECLAIM,("%s %d: (first_unused_area_offset=0x%08x,i=0x%08x,j4fs_end=0x%08x)\n",__FUNCTION__,__LINE__,first_unused_area_offset,i,device_info.j4fs_end));
+			ret = FlashDevWrite(&device_info, first_unused_area_offset+i, J4FS_BASIC_UNIT_SIZE, buf_data);
+			if (error(ret)) {
+				J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+		   		goto error1;
+			}
+		}
+	}
+#endif
+
+reclaim_done:
+	j4fs_rw_start=mst->rw_start;
+
+	// Handle the exception
+	if(!j4fs_rw_start ||(j4fs_rw_start>= device_info.j4fs_end))
+	{
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: j4fs_rw_start is set to default value(128KB)\n",__FUNCTION__,__LINE__));
+		j4fs_rw_start=device_info.j4fs_offset;
+	}
+
+	if(!ro_j4fs_header_count) fsd_read_ro_header();
+
+#ifdef __KERNEL__
+	kfree(buf_mst);
+	kfree(buf_header);
+	kfree(buf_data);
+#ifdef J4FS_TRANSACTION_LOGGING
+	kfree(transaction);
+#endif
+#endif
+
+	J4FS_T(J4FS_TRACE_FSD_RECLAIM,("\n%s %d: Reclaim Done\n",__FUNCTION__,__LINE__));
+	fsd_print_meta_data();
+
+	return J4FS_SUCCESS;
+
+error1:
+	J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+
+	// Handle the exception
+	if(!j4fs_rw_start ||(j4fs_rw_start>= device_info.j4fs_end))
+	{
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: j4fs_rw_start is set to default value(128KB)\n",__FUNCTION__,__LINE__));
+		j4fs_rw_start=device_info.j4fs_offset;
+	}
+
+	if(!ro_j4fs_header_count) fsd_read_ro_header();
+	fsd_print_meta_data();
+
+#ifdef __KERNEL__
+	kfree(buf_mst);
+	kfree(buf_header);
+	kfree(buf_data);
+#ifdef J4FS_TRANSACTION_LOGGING
+	kfree(transaction);
+#endif
+#endif
+	return J4FS_FAIL;
+}
+
+// invalidate old valid files
+int fsd_mark_invalid()
+{
+	DWORD offset;
+	j4fs_header *header;
+	DWORD valid_offset[128][2];
+	int index=0;
+	int i,j;
+	j4fs_mst *mst;
+	int ret=-1;
+
+#ifdef __KERNEL__
+	BYTE *buf;
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+#else
+	BYTE buf[J4FS_BASIC_UNIT_SIZE];
+#endif
+
+	mst=(j4fs_mst *)buf;
+
+	// read mst
+	ret = FlashDevRead(&device_info, 0, J4FS_BASIC_UNIT_SIZE, buf);
+	if (error(ret)) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+   		goto error1;
+	}
+
+	if(mst->magic==J4FS_MAGIC)
+	{
+		// the start address of the RW area of the device (partition)
+		offset=mst->rw_start;
+
+		if(!offset ||(offset>= device_info.j4fs_end))
+		{
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error! rw_start is invalid(j4fs_rw_start=0x%08x, j4fs_end=0x%08x)\n", __FUNCTION__, __LINE__, mst->rw_start, device_info.j4fs_end));
+			j4fs_panic("rw_start is invalid");
+			goto error1;
+		}
+	}
+	else
+	{
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error! MST is invalid\n", __FUNCTION__, __LINE__));
+		j4fs_panic("MST is invalid");
+		goto error1;
+	}
+
+	// trace all RW object header
+	while(offset!=0xffffffff)
+	{
+		// read j4fs_header
+		ret = FlashDevRead(&device_info, offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (error(ret)) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+	   		goto error1;
+		}
+		header=(j4fs_header *)buf;
+
+		//This j4fs_header cannot be interpreted. It means there are no RW files in this partition(this can happen and this is a normal case) or
+		//this j4fs partition is crashed(this should not happen).
+		if(header->type!=J4FS_FILE_TYPE)
+		{
+			// There are no RW files in this partition or this first j4fs_header is crashed. Before we write data of new file, user of j4fs should write j4fs_header of new file.
+			// So, this case should not happen and/or should be repaired.
+			if(offset==mst->rw_start) {
+				j4fs_panic("There are no RW files in this partition or this first RW j4fs_header is crashed. Before we write data of new file, user of j4fs should write j4fs_header of new file. So, this case should not happen and/or should be repaired..");
+				goto error1;
+			}
+
+			// This j4fs partition is crashed by some abnormal cause. This should not happen and should be repaired.
+			j4fs_panic("this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		// This file was deleted, so read next j4fs_header.
+		if((header->flags&0x1)!=((header->flags&0x2)>>1))
+		{
+			offset=header->link;
+			continue;
+		}
+
+		// This file is valid.
+		valid_offset[index][0]=header->id;
+		valid_offset[index][1]=offset;
+		index++;
+		offset=header->link;
+	}
+
+	J4FS_T(J4FS_TRACE_FSD_PRINT_META_DATA,("%s %d: index=%d\n",__FUNCTION__,__LINE__,index));
+
+	// Invalidate old files. we exclude last object header because last object header can't decide invalidation of old files
+	for(i=0;i<index-2;i++)
+	{
+		for(j=i+1;j<index-1;j++)
+		{
+			// If inode number is same, invalidate old object
+			if(valid_offset[i][0]==valid_offset[j][0])
+			{
+				//J4FS_T(J4FS_TRACE_FSD_PRINT_META_DATA,("%s %d\n",__FUNCTION__,__LINE__));
+
+				// read j4fs_header
+				ret = FlashDevRead(&device_info, valid_offset[i][1], J4FS_BASIC_UNIT_SIZE, buf);
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			   		goto error1;
+				}
+				header=(j4fs_header *)buf;
+
+				//This j4fs_header cannot be interpreted. It means there are no RW files in this partition(this can happen and this is a normal case) or
+				//this j4fs partition is crashed(this should not happen).
+				if(header->type!=J4FS_FILE_TYPE)
+				{
+					// There are no RW files in this partition or this first j4fs_header is crashed. Before we write data of new file, user of j4fs should write j4fs_header of new file.
+					// So, this case should not happen and/or should be repaired.
+					if(offset==mst->rw_start) {
+						j4fs_panic("There are no RW files in this partition or this first RW j4fs_header is crashed. Before we write data of new file, user of j4fs should write j4fs_header of new file. So, this case should not happen and/or should be repaired..");
+						goto error1;
+					}
+
+					// This j4fs partition is crashed by some abnormal cause. This should not happen and should be repaired.
+					j4fs_panic("this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+					goto error1;
+				}
+
+				// this file will be deleted
+				header->flags=0x1;
+
+				ret = FlashDevWrite(&device_info, valid_offset[i][1], J4FS_BASIC_UNIT_SIZE, buf);
+				if (error(ret)) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			   		goto error1;
+				}
+				break;
+			}
+		}
+	}
+
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+
+	return J4FS_SUCCESS;
+
+error1:
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_FAIL;
+}
+
+
+int fsd_special(j4fs_ctrl *ctl)
+{
+	return FlashDevSpecial(&device_info,ctl->scmd);
+}
+
+// Read j4fs_header list of RO area
+int fsd_read_ro_header(void)
+{
+	DWORD offset;
+	j4fs_header *header;
+	int i;
+	int ret=-1;
+
+#ifdef __KERNEL__
+	BYTE *buf;
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+#else
+	BYTE buf[J4FS_BASIC_UNIT_SIZE];
+#endif
+
+	ro_j4fs_header_count=0;
+
+	// the start address of the device (partition)
+	offset=	device_info.j4fs_offset;
+
+	// scanning all j4fs_header of RO area.
+	while(offset<j4fs_rw_start)
+	{
+		// read j4fs_header
+		ret = FlashDevRead(&device_info, offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (error(ret)) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			goto error1;
+		}
+		header=(j4fs_header *)buf;
+
+		//This j4fs_header cannot be interpreted.
+		if(header->type!=J4FS_FILE_TYPE)
+		{
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: ERROR! RO file cannot be interpreted. (offset=%d)\n",__FUNCTION__,__LINE__,offset));
+			j4fs_panic("This j4fs_header cannot be interpreted. So this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		// This file was deleted, so read next j4fs_header.
+		if((header->flags&0x1)!=((header->flags&0x2)>>1))
+		{
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: ERROR! RO file was deleted. (offset,ino,filename)=(%d,%d,%s)\n",__FUNCTION__,__LINE__,offset,header->id,header->filename));
+			offset=header->link;
+			continue;
+		}
+
+		if(ro_j4fs_header_count>=J4FS_MAX_RO_FILES_NUMBER)
+		{
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: ERROR! Too many ro files\n",__FUNCTION__,__LINE__));
+
+			j4fs_traceMask |= J4FS_TRACE_FSD_PRINT_META_DATA;
+			fsd_print_meta_data();
+			j4fs_traceMask &= ~J4FS_TRACE_FSD_PRINT_META_DATA;
+			goto error1;
+		}
+
+		memcpy(ro_j4fs_header+ro_j4fs_header_count, header, sizeof(j4fs_header));
+		ro_j4fs_header_count++;
+
+		offset=header->link;
+	}
+
+	J4FS_T(J4FS_TRACE_FSD_PRINT_META_DATA,("\n====================== %s %d ================================\n", __FUNCTION__,__LINE__));
+
+	for(i=0;i<ro_j4fs_header_count;i++)
+	{
+		J4FS_T(J4FS_TRACE_FSD_PRINT_META_DATA,("%d : (link,type,flags,id,length,filename)=(0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,%s)\n",(i+1),ro_j4fs_header[i].link, ro_j4fs_header[i].type, ro_j4fs_header[i].flags, ro_j4fs_header[i].id, ro_j4fs_header[i].length, ro_j4fs_header[i].filename));
+	}
+
+	J4FS_T(J4FS_TRACE_FSD_PRINT_META_DATA,("\n====================== %s %d ================================\n", __FUNCTION__,__LINE__));
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_SUCCESS;
+
+error1:
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_FAIL;
+
+}
+
+#ifdef J4FS_TRANSACTION_LOGGING
+int fsd_initialize_transaction()
+{
+	int i, ret;
+	DWORD sequence=0,offset=0xffffffff;
+	j4fs_transaction *transaction;
+
+#ifdef __KERNEL__
+	BYTE *buf;
+	buf=kmalloc(J4FS_TRANSACTION_SIZE,GFP_NOFS);
+#else
+	BYTE buf[J4FS_TRANSACTION_SIZE];
+#endif
+
+	transaction=(j4fs_transaction *)buf;
+
+	for(i=device_info.j4fs_end+1; i<device_info.j4fs_device_end; i+=J4FS_TRANSACTION_SIZE)
+	{
+		ret = FlashDevRead(&device_info, i, J4FS_TRANSACTION_SIZE, buf);
+		if (error(ret)) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(ret=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+	   		goto error1;
+		}
+
+		if(transaction->magic!=J4FS_MAGIC) continue;
+		if(sequence<transaction->sequence)
+		{
+			sequence=transaction->sequence;
+			offset=i;
+		}
+	}
+
+	// there are no file system transaction
+	if(offset==0xffffffff)
+	{
+		j4fs_next_sequence=1;
+		j4fs_transaction_next_offset=device_info.j4fs_end+1;
+	}
+	else
+	{
+		j4fs_next_sequence=sequence+1;
+		j4fs_transaction_next_offset=offset+512;
+
+		if(j4fs_transaction_next_offset>=device_info.j4fs_device_end) j4fs_transaction_next_offset=device_info.j4fs_end+1;
+	}
+
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_SUCCESS;
+
+error1:
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_FAIL;
+}
+#endif
+
+int fsd_panic()
+{
+	j4fs_mst *mst;
+	int ret=-1;
+
+#ifdef __KERNEL__
+	BYTE *buf;
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+#else
+	BYTE buf[J4FS_BASIC_UNIT_SIZE];
+#endif
+
+	j4fs_panic=1;
+
+	// Marking j4fs panic by writing J4FS_PANIC to mst->status
+	ret = FlashDevRead(&device_info, 0, J4FS_BASIC_UNIT_SIZE, buf);
+	if (error(ret)) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error\n",__FUNCTION__,__LINE__));
+   		goto error1;
+	}
+
+	mst=(j4fs_mst *)buf;
+	mst->status|=J4FS_PANIC;
+
+	ret = FlashDevWrite(&device_info, 0, J4FS_BASIC_UNIT_SIZE, buf);
+	if (error(ret)) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+   		goto error1;
+	}
+
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_SUCCESS;
+
+error1:
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_FAIL;
+}
+
+int fsd_print_meta_data()
+{
+	DWORD offset;
+	j4fs_header *header;
+	j4fs_mst *mst;
+	int i;
+	int ret=-1;
+
+#ifdef __KERNEL__
+	BYTE *buf;
+	buf=kmalloc(4096,GFP_NOFS);
+#else
+	BYTE buf[4096];
+#endif
+
+	if(!(j4fs_traceMask|J4FS_TRACE_FSD_PRINT_META_DATA)) return 0;
+
+	// print MST
+	ret = FlashDevRead(&device_info, 0, J4FS_BASIC_UNIT_SIZE, buf);
+	if (error(ret)) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error\n",__FUNCTION__,__LINE__));
+   		goto error1;
+	}
+
+	J4FS_T(J4FS_TRACE_FSD_PRINT_META_DATA,("====================================================================\n"));
+
+	mst=(j4fs_mst *)buf;
+	J4FS_T(J4FS_TRACE_FSD_PRINT_META_DATA,("(magic,from,to,end,offset_number,status,rw_start)=(0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,0x%08x)\n",
+		mst->magic,mst->from,mst->to,mst->end,mst->offset_number,mst->status,mst->rw_start));
+
+	if(mst->magic==J4FS_MAGIC && mst->offset_number)
+	{
+		J4FS_T(J4FS_TRACE_FSD_PRINT_META_DATA,("offset: "));
+		for(i=0;i<mst->offset_number;i++)
+			J4FS_T(J4FS_TRACE_FSD_PRINT_META_DATA,("0x%x ", mst->offset[i]));
+		J4FS_T(J4FS_TRACE_FSD_PRINT_META_DATA,("\n"));
+	}
+
+	// the start address of the device (partition)
+	offset=	device_info.j4fs_offset;
+
+	i=0;
+	while(1)
+	{
+		// read j4fs_header
+		ret = FlashDevRead(&device_info, offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (error(ret)) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+	   		goto error1;
+		}
+		header=(j4fs_header *)buf;
+
+		//This j4fs_header cannot be interpreted.
+		if(header->type!=J4FS_FILE_TYPE) break;
+
+		J4FS_T(J4FS_TRACE_FSD_PRINT_META_DATA,("%d : (link,type,flags,id,length,filename)=(0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,%s)\n",++i,header->link,header->type,header->flags,header->id,header->length,header->filename));
+
+		// this is last enry in the device
+		if(header->link==0xffffffff)
+		{
+			break;
+		}
+		else
+		{
+			offset += J4FS_BASIC_UNIT_SIZE;	// header
+			offset += header->length;	// data
+			offset = (offset+J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE;	// 4096 align
+			if(mst->from && offset>=mst->to) offset=mst->from;	// In case of power-off when reclaim(mst-from>0), skip from 'to offset' to 'from offset'
+		}
+	}
+
+	J4FS_T(J4FS_TRACE_FSD_PRINT_META_DATA,("====================================================================\n"));
+
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_SUCCESS;
+
+error1:
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_FAIL;
+}
diff -rupN kernel-s2-ics-update7/drivers/samsung/j4fs/j4fs.h kernel/drivers/samsung/j4fs/j4fs.h
--- kernel-s2-ics-update7/drivers/samsung/j4fs/j4fs.h	1970-01-01 07:30:00.000000000 +0730
+++ kernel/drivers/samsung/j4fs/j4fs.h	2012-07-27 21:37:57.000000000 +0800
@@ -0,0 +1,493 @@
+/*
+ * Copyright (C) 2008, 2009,  Samsung Electronics Co. Ltd. All Rights Reserved.
+ *       Written by Linux Lab, MITs Development Team, Mobile Communication Division.
+ */
+
+/*
+ * J4FS
+ *
+ * Jong Jang Jintae Jongmin File System is based on LFS(Linear File Store)
+ *
+ *
+ * 2009.02 - First editing by SungHwan.yun <sunghwan.yun@samsung.com> @LDK@
+ *
+ * 2009.03 - Currently managed by  SungHwan.yun <sunghwan.yun@samsung.com> @LDK@
+ *
+ * 2009.12 - Version 1.0 Released by SungHwan.yun <sunghwan.yun@samsung.com> @LDK@
+ *
+ */
+
+#ifdef __KERNEL__
+#include <linux/version.h>
+#include <linux/types.h>
+#include <asm/types.h>
+#include <linux/spinlock.h>
+#include <linux/fs.h>
+#include <linux/mount.h>
+#include <linux/buffer_head.h>
+
+#ifndef BYTE
+#define BYTE __u8
+#endif
+
+#ifndef WORD
+#define WORD __u16
+#endif
+
+#ifndef HWORD
+#define HWORD __u16
+#endif
+
+#ifndef DWORD
+#define DWORD __u32
+#endif
+
+#define PRINT printk
+
+#else
+
+#ifndef BYTE
+#define BYTE unsigned char
+#endif
+
+#ifndef WORD
+#define WORD unsigned int
+#endif
+
+#ifndef HWORD
+#define HWORD unsigned int
+#endif
+
+#ifndef DWORD
+#define DWORD unsigned int
+#endif
+
+#define PRINT printf
+
+#endif
+
+/**********************************************************
+ * This is porting values
+ **********************************************************/
+#define PHYSICAL_PAGE_SIZE		2048		// 4KB
+#define PHYSICAL_BLOCK_SIZE	PHYSICAL_PAGE_SIZE*64		// 256KB
+#define J4FS_PARTITION_ID		21
+#undef J4FS_USE_XSR							// NO XSR
+// J4FS for moviNAND merged from ROSSI
+#undef J4FS_USE_FSR						// FSR
+#define J4FS_USE_MOVI
+
+#if defined(J4FS_USE_MOVI)
+#define J4FS_BLOCK_COUNT	20
+#endif
+// J4FS for moviNAND merged from ROSSI
+
+/*
+ * J4FS Version(J4FS_1.0.0p0_b0)
+ */
+#define J4FS_VER_MAJOR			1
+#define J4FS_VER_MINOR1			0
+#define J4FS_VER_MINOR2			0
+#define J4FS_VER_PATCHLEVEL		0
+#define J4FS_BUILD_NUMBER		0
+
+
+/*
+ * file header(j4fs_header) and data block and media status table(j4fs_mst) size
+ */
+#define J4FS_BASIC_UNIT_SIZE			2048
+#define J4FS_BASIC_UNIT_SIZE_BITS		11
+
+/*
+ * File name length
+ */
+#define J4FS_NAME_LEN 128
+
+/*
+ * Max RO file number
+ */
+#define J4FS_MAX_RO_FILES_NUMBER 200
+
+/*
+  * Max file number in J4FS
+ */
+#define J4FS_MAX_FILE_NUM	256
+
+/*
+ * Special inode numbers
+ */
+#define J4FS_BAD_INO		 1	/* Bad blocks inode */
+#define J4FS_ROOT_INO		 2	/* Root inode */
+#define J4FS_BOOT_LOADER_INO	 5	/* Boot loader inode */
+#define J4FS_UNDEL_DIR_INO	 6	/* Undelete directory inode */
+#define J4FS_FIRST_INO	11 /* First non-reserved inode */
+
+/*
+  * Reclaim status
+ */
+#define J4FS_RECLAIM_DONE							0x01230000	// This value should not be zero becaust of POR
+#define J4FS_RECLAIM_MOVING_DATA_STEP_1		0x00000001
+#define J4FS_RECLAIM_MOVING_DATA_STEP_2		0x00000002
+#define J4FS_RECLAIM_UPDATE_LINK					0x00000004
+#define J4FS_RECLAIM_LAST_OBJECT					0x10000000
+#define J4FS_PANIC										0x00005a00
+#define J4FS_PANIC_MASK								0x0000ff00
+
+// Debug
+#define J4FS_TRACE_FSD					0x00000001
+#define J4FS_TRACE_FS						0x00000002
+#define J4FS_TRACE_FS_READ				0x00000004
+#define J4FS_TRACE_LOCK					0x00000008
+#define J4FS_TRACE_FSD_RECLAIM		0x00000010
+#define J4FS_TRACE_FSD_PRINT_META_DATA		0x00000020
+
+#define J4FS_TRACE_ALWAYS		0xF0000000
+
+/*
+ * Define return value
+ */
+#define J4FS_SUCCESS			0x0
+#define J4FS_RETRY_WRITE		0x20000000
+#define J4FS_FAIL					0x40000000
+#define J4FS_NO_FILE			0x40001000
+
+/*
+ * opcode : j4fs transaction for j4fs crash debugging
+ */
+#define J4FS_LAST_OBJECT_CREATE_STEP1							0x1		// 1,4,10
+#define J4FS_LAST_OBJECT_CREATE_STEP2							0x2		// 1,4,10
+#define J4FS_LAST_OBJECT_WRITE_EXTEND1						0x10		// 2,3,5,6
+#define J4FS_LAST_OBJECT_WRITE_EXTEND2						0x20		// 8
+#define J4FS_NOLAST_OBJECT_WRITE_EXTEND_STEP1			0x100		// 9,11,12,13
+#define J4FS_NOLAST_OBJECT_WRITE_EXTEND_STEP2			0x110	// 9,11,12,13
+#define J4FS_NOLAST_OBJECT_WRITE_EXTEND_STEP3			0x120	// 9,11,12,13
+#define J4FS_RECLAIM_STEP1											0x1000	// reclaim
+#define J4FS_RECLAIM_STEP2											0x2000	// reclaim
+
+#define J4FS_RECLAIM_RESET_UNUSED_SPACE
+#define J4FS_TRANSACTION_LOGGING
+
+#define J4FS_T(mask, p) do { if ((mask) & (j4fs_traceMask | J4FS_TRACE_ALWAYS)) TOUT(p); } while (0)
+#define POR(mask, p, q) do { if (((mask) & (j4fs_PORMask))&&!(--j4fs_PORCount)) {TOUT(p); while(1); }} while (0)
+
+#define error(ret)	(ret>=J4FS_FAIL)
+
+#ifdef __KERNEL__
+#define j4fs_panic(str)		\
+do {							\
+	J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: "str"\n",__FUNCTION__,__LINE__));	\
+	fsd_panic();		\
+	dump_stack();	\
+} while (0)
+#else
+#define j4fs_panic(str)		\
+do {							\
+	J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: "str"\n",__FUNCTION__,__LINE__));	\
+	fsd_panic();	\
+} while (0)
+#endif
+
+#ifdef __KERNEL__
+#define j4fs_dump(str)		\
+do {							\
+	J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: "str"\n",__FUNCTION__,__LINE__));	\
+	dump_stack();	\
+} while (0)
+#else
+#define j4fs_dump(str)		\
+do {							\
+	J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: "str"\n",__FUNCTION__,__LINE__));	\
+	while(1);	\
+} while (0)
+#endif
+
+
+#define j4fs_check_partition_range(offset)		\
+do {		\
+	if(offset + J4FS_BASIC_UNIT_SIZE > device_info.j4fs_end) {	\
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: offset overflow(offset=0x%08x, j4fs_end=0x%08x)\n", __FUNCTION__, __LINE__, offset, device_info.j4fs_end));	\
+		j4fs_panic("offset overflow!!");	\
+		goto error1;	\
+	}	\
+} while(0)
+
+
+
+#ifdef __KERNEL__
+/*
+ * Flash data structure of the super block
+ */
+struct j4fs_super_block {
+	unsigned long pad;
+};
+
+/*
+ * Memory data structure of the super block
+ */
+struct j4fs_sb_info {
+	struct j4fs_super_block * s_es;	/* Pointer to the super block in the buffer */
+	unsigned long	s_log_block_size;	/* Block size(0:1024, 1:2048, 3:4096)*/
+	int s_first_ino;
+};
+
+/*
+ * Flash data structure of the inode
+ */
+struct j4fs_inode {
+	__le32 i_link;
+	__le32 i_size;
+	__le32 i_type;
+	__le32 i_offset;
+	__le32 i_flags;
+	__le32 i_stroff;
+	__le32 i_id;
+	__le32	i_length;
+	__u8 i_filename[J4FS_NAME_LEN];
+};
+
+/*
+ * Memory data structure of the inode
+ */
+struct j4fs_inode_info {
+	__le32 i_link;
+	__le32 i_type;
+	__le32 i_flags;
+	__le32 i_id;
+	__le32	i_length;
+	__u8 i_filename[J4FS_NAME_LEN];
+	rwlock_t i_meta_lock;
+	struct inode	vfs_inode;
+};
+
+#endif
+
+
+#define J4FS_INIT				1
+#define J4FS_GET_INFO		2
+#define J4FS_EXIT			4
+
+#ifndef __KERNEL__
+#define J4FS_FORMAT		3
+#endif
+
+#define J4FS_FILE_TYPE		0x12345678
+#define J4FS_MAGIC			0x87654321
+
+/*
+  * device : This field indicates the device(partition) number to be acted upon. Device can also be thought of as a partition. This field is STL partition id.
+  * status : This field provides a mechanism to pass a detailed failure back to the application. Typical functions will place a detailed error in this field
+  *               and return SUCCESS or FAILURE back to the calling function.
+  * buffer  : This field provides a pointer to a memory buffer to translate data either to or from a function
+  * count  : This field indicates the number of bytes transferred. This field is usually used on write operations
+  * actual  : This field indicates whether or not a read or write is possible to a position by comparing the requested source file size with the actual size
+  *              of the target position.
+  * scmd   : This field provides a subcommand for possible use in the future
+  * type    : PCMCIA requires that LFS headers contain a stamp indicating the type of the header. For our implementation, this field has been assigned
+  *              ZERO (0), indicating the 32 byte header above.
+  * id        : This value is unique to each file object. This unique id field is to be used as a file identifier
+  * aux     : This field does not get initialized in the FlashDevMount function. It provides a mechanism to pass extra information to/from the low-level
+  *              function set
+  * index   : file offset to read or write
+ */
+typedef struct {
+	DWORD device;
+	DWORD status;
+	BYTE *buffer;
+	DWORD count;
+	DWORD actual;
+	DWORD scmd;
+	DWORD type;
+	DWORD id;
+	DWORD aux;
+	DWORD index;
+} j4fs_ctrl;
+
+
+/*
+  * we assume j4fs_header is aligned with page size
+  *
+  * link     : This field contains the offset from the start of this header to the next LFS header in the device(partition). If each bit in this field is equal to bit D0
+  *             of the flags field, this is the last entry in the device.
+  * size    : This is the actual size of the LFS header. [Obsoleted]
+  * type   : PCMCIA requires that LFS headers contain a stamp indicating the type of the header. For our implementation, this field has been assigned ZERO
+  *             (0), indicating the 32-byte header above. This type field is assigned to this header to distinguish it from other headers that may exist
+  *             in the device. This prevents the FSD from reading a header it cannot interpret.
+  * offset : This field indicates how far from the start of this header into the entry the file data begins. This allows LFS implementations that use extended
+  *             headers to be compatible with drivers that can't read the extended header.[Obsoleted]
+  * flags   : This is a bit-mapped flags field. Bit D0 indicates the nature of the flash (1 erase or 0 erase). Bit D1 indicates whether or not this file entry is
+  *             valid or deleted: if D1 matches D0 the file is valid, if D1 differs, than that file is deleted
+  * stroff  : This field points to the extended header associated with this file. The actual location of the filename string is determined by adding the value
+  *             in this field to the address of the LFS_HEADER. If this field is zero, there is no filename.[Obsoleted]
+  * id       : This value is unique to each file object. This unique id field is to be used as a file identifier
+  * length : file data length
+  * filename : filename
+*/
+typedef struct {
+	DWORD link;
+	DWORD size;
+	DWORD type;
+	DWORD offset;
+	DWORD flags;
+	DWORD stroff;
+	DWORD id;
+	DWORD length;
+	BYTE filename[J4FS_NAME_LEN];
+} j4fs_header;
+
+
+/*
+  * device  : This field indicates the device (partition) number to be acted upon. Device can also be thought of as a partition. This field is STL partition id.
+  * status  : This field provides a mechanism to pass a detailed failure back to the application. Typical functions will place a detailed error in this field and
+                   return SUCCESS or FAILURE back to the calling function
+  * blocksize : This field should be initialized by the FlashDevMount function and provides a mechanism to allow multiple devices (partitions) with
+  *                  different Intel components (which may have different block sizes). This field should reflect the size of media that will be erased when
+  *                  one block is erased in Bytes.
+  * pagesize  : This field indicates the size of page in Bytes.
+  * numberblocks : This field indicates the number of blocks in the entire media. If their are two flash cards, each would be considered its own media.
+  *                         If the media is an RFA, each RFA is considered its own media
+  * j4fs_offset : This field indicates the beginning address of data area of the device (partition) in Bytes. This address follows the
+  *                     Media Status Table(MST) and MST starts from offset 0.
+  * j4fs_size : This value indicates the size of the device (partition) in Bytes.
+  * j4fs_end : This field indicates the address of the end of the current device(partition) in Bytes. The device(partition) starts from offset 0.
+  * aux : This field does not get initialized in the FlashDevMount function. It provides a mechanism to pass extra information to/from the low-level function set
+  */
+typedef struct {
+	DWORD device;
+	DWORD status;
+	DWORD blocksize;
+	DWORD pagesize;
+	DWORD numberblocks;
+	DWORD j4fs_offset;
+	DWORD j4fs_size;
+	DWORD j4fs_end;
+	DWORD j4fs_device_end;
+	DWORD aux;
+
+#ifdef __KERNEL__
+	struct semaphore grossLock;	/* Gross locking semaphore */
+#endif
+} j4fs_device_info;
+
+
+/*
+  * J4FS Media Status Table(MST)
+  * This structure is used for reclaim including POR. The MST will reserve one block and will be used during initialization and reclaim.
+  * This MST is intended to assist in making the J4FS more robust. It provides memory to store status updates when reclaim is occurring,
+  * so that the system may recover form an unexpected power-off. If (from,to,end) is all 0, no reclaim is needed or reclaim is done.(Initial state)
+       If (from,to,end) is not 0, reclaim is in progress and should reclaim-restart from 'from,to member'
+  * magic : J4FS_MAGIC
+  * from , to(Bytes) : copy from 'from offset' to 'to offset' (4096Bytes data).
+  * end(Bytes) : end offset of 'from offset'.
+  * offset(Bytes) : beginning offsets of new arranged valid files excluding invalid files
+  * offset_number : number of offset array
+  */
+typedef struct {
+	DWORD magic;
+	DWORD from;
+	DWORD to;
+	DWORD end;
+	DWORD copyed;
+	DWORD offset[J4FS_MAX_FILE_NUM];
+	DWORD offset_number;
+	DWORD status;
+	DWORD rw_start;
+} j4fs_mst;
+
+#ifdef J4FS_TRANSACTION_LOGGING
+/*
+  * transaction structure for j4fs crash debugging. size should be 512B.
+  */
+typedef struct {
+	DWORD offset;
+	DWORD opcode;
+	DWORD sequence;
+	DWORD magic;
+
+	DWORD ino;
+	DWORD index;
+	DWORD count;
+	DWORD reserved1;
+
+	DWORD b_link;
+	DWORD b_length;
+	DWORD a_link;
+	DWORD a_length;
+
+	BYTE filename[J4FS_NAME_LEN];
+	BYTE reserved2[336];
+} j4fs_transaction;
+
+#define J4FS_TRANSACTION_SIZE	512
+#endif
+
+extern int j4fs_close(void);
+
+#ifdef __KERNEL__
+extern ino_t j4fs_inode_by_name(struct inode * dir, struct dentry *dentry);
+extern struct inode *j4fs_alloc_inode(struct super_block *sb);
+extern void j4fs_destroy_inode(struct inode *inode);
+extern void j4fs_read_inode (struct inode * inode);
+extern int  j4fs_init(void);
+extern void print_j4fs_inode(struct j4fs_inode *raw_inode);
+extern int j4fs_get_block(struct inode *inode, sector_t iblock, struct buffer_head *bh_result,  int create);
+extern int j4fs_get_blocks(struct inode *inode, sector_t iblock, unsigned long maxblocks, struct buffer_head *bh_result,  int create);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+extern int j4fs_permission(struct inode *inode, int mask);
+#else
+extern int j4fs_permission(struct inode *inode, int mask, struct nameidata *nd);
+#endif
+
+extern int j4fs_readpage_unlock(struct file *f, struct page *page);
+extern int j4fs_readpage_nolock(struct file *f, struct page *page);
+extern int j4fs_file_write(struct file *f, const char *buf, size_t n,loff_t *pos);
+extern int j4fs_hold_space(int size);
+
+extern void msleep(unsigned int msecs);
+
+extern const struct inode_operations j4fs_file_inode_operations;
+extern const struct file_operations j4fs_file_operations;
+extern const struct inode_operations j4fs_dir_inode_operations;
+extern const struct file_operations j4fs_dir_operations;
+extern const struct address_space_operations j4fs_aops;
+extern const struct super_operations j4fs_sops;
+
+static inline struct j4fs_inode_info *J4FS_I(struct inode *inode)
+{
+	return container_of(inode, struct j4fs_inode_info, vfs_inode);
+}
+#else
+extern int j4fs_test(void);
+extern int j4fs_open(void);
+#endif
+
+
+extern int fsd_open(j4fs_ctrl *);
+extern int fsd_close(j4fs_ctrl *);
+extern int fsd_read(j4fs_ctrl *);
+extern int fsd_write(j4fs_ctrl *);
+extern int fsd_delete(j4fs_ctrl *);
+extern int fsd_special(j4fs_ctrl *);
+extern int fsd_print_meta_data(void);
+extern int fsd_read_ro_header(void);
+extern int fsd_mark_invalid(void);
+extern int fsd_reclaim(void);
+extern int fsd_panic(void);
+extern int is_invalid_j4fs_rw_start(void);
+#ifdef J4FS_TRANSACTION_LOGGING
+extern int fsd_initialize_transaction(void);
+#endif
+
+extern int FlashDevRead(j4fs_device_info *dev_ptr, DWORD offset, DWORD length, BYTE *buffer);
+extern int FlashDevWrite(j4fs_device_info *dev_ptr, DWORD offset, DWORD length, BYTE *buffer);
+extern int FlashDevErase(j4fs_device_info *dev_ptr);
+extern int FlashDevMount(void);
+extern int FlashDevUnmount(void);
+extern int FlashDevSpecial(j4fs_device_info *dev_ptr, DWORD scmd);
+
+#ifdef __KERNEL__
+#define TOUT(p) printk p
+#else
+#define TOUT(p) printf p
+#endif
+
diff -rupN kernel-s2-ics-update7/drivers/samsung/j4fs/j4fs_kernel.c kernel/drivers/samsung/j4fs/j4fs_kernel.c
--- kernel-s2-ics-update7/drivers/samsung/j4fs/j4fs_kernel.c	1970-01-01 07:30:00.000000000 +0730
+++ kernel/drivers/samsung/j4fs/j4fs_kernel.c	2012-07-27 21:37:57.000000000 +0800
@@ -0,0 +1,1526 @@
+/*
+ * j4fs_fs.c
+ *
+ * External interface to other kernel subsystems
+ *
+ * COPYRIGHT(C) Samsung Electronics Co.Ltd. 2009-2010 All Right Reserved.
+ *
+ * 2009.02 - First editing by SungHwan.yun <sunghwan.yun@samsung.com> @LDK@
+ *
+ * 2009.03 - Currently managed by  SungHwan.yun <sunghwan.yun@samsung.com> @LDK@
+ *
+ */
+#include <linux/time.h>
+#include <linux/highuid.h>
+#include <linux/pagemap.h>
+#include <linux/quotaops.h>
+#include <linux/module.h>
+#include <linux/writeback.h>
+#include <linux/buffer_head.h>
+#include <linux/mpage.h>
+#include <linux/slab.h>
+#include <linux/semaphore.h>
+#include "j4fs.h"
+
+#if defined(J4FS_USE_XSR)
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28))
+#include "./Inc/XsrTypes.h"
+#include "./Inc/STL.h"
+#else
+#include "../../drivers/txsr/Inc/XsrTypes.h"
+#include "../../drivers/txsr/Inc/STL.h"
+#endif
+
+#elif defined(J4FS_USE_FSR)
+
+#include "../../fsr/Inc/FSR.h"
+#include "../../fsr/Inc/FSR_STL.h"
+
+// J4FS for moviNAND merged from ROSSI
+#elif defined(J4FS_USE_MOVI)
+// J4FS for moviNAND merged from ROSSI
+#else
+'compile error'
+#endif
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 27))
+#define J4FS_USE_WRITE_BEGIN_END 1
+#else
+#define J4FS_USE_WRITE_BEGIN_END 0
+#endif
+
+#define Page_Uptodate(page)	test_bit(PG_uptodate, &(page)->flags)
+
+extern j4fs_device_info device_info;
+extern unsigned int j4fs_traceMask;
+extern unsigned int j4fs_rw_start;
+extern int ro_j4fs_header_count;
+extern unsigned int j4fs_next_sequence;
+extern unsigned int j4fs_transaction_next_offset;
+extern int j4fs_panic;
+
+void j4fs_GrossLock(void)
+{
+	J4FS_T(J4FS_TRACE_LOCK, ("j4fs locking %p\n", current));
+	down(&device_info.grossLock);
+	J4FS_T(J4FS_TRACE_LOCK, ("j4fs locked %p\n", current));
+}
+
+void j4fs_GrossUnlock(void)
+{
+	J4FS_T(J4FS_TRACE_LOCK, ("j4fs unlocking %p\n", current));
+	up(&device_info.grossLock);
+}
+
+int j4fs_readpage(struct file *f, struct page *page)
+{
+	J4FS_T(J4FS_TRACE_FS_READ,("%s %d\n",__FUNCTION__,__LINE__));
+	return j4fs_readpage_unlock(f, page);
+}
+
+int j4fs_readpage_unlock(struct file *f, struct page *page)
+{
+	int ret = j4fs_readpage_nolock(f, page);
+	unlock_page(page);
+	return ret;
+}
+
+int j4fs_readpage_nolock(struct file *f, struct page *page)
+{
+	/* Lifted from yaffs2 */
+	unsigned char *page_buf;
+	int ret;
+	struct address_space *mapping = page->mapping;
+	struct inode *inode;
+	j4fs_ctrl ctl;
+
+	J4FS_T(J4FS_TRACE_FS_READ,("%s %d\n",__FUNCTION__,__LINE__));
+
+	BUG_ON(!PageLocked(page));
+
+	if (!mapping) BUG();
+
+	inode = mapping->host;
+
+	if (!inode) BUG();
+
+	page_buf = kmap(page);
+	/* FIXME: Can kmap fail? */
+
+	j4fs_GrossLock();
+
+	ctl.buffer=page_buf;
+	ctl.count=PAGE_CACHE_SIZE;
+	ctl.id=inode->i_ino;
+	ctl.index=page->index << PAGE_CACHE_SHIFT;
+	ret=fsd_read(&ctl);
+
+	j4fs_GrossUnlock();
+
+	if (ret >= 0)
+		ret = 0;
+
+	if (ret) {
+		ClearPageUptodate(page);
+		SetPageError(page);
+	} else {
+		SetPageUptodate(page);
+		ClearPageError(page);
+	}
+
+	flush_dcache_page(page);
+	kunmap(page);
+
+	return ret;
+}
+
+int j4fs_writepage(struct page *page, struct writeback_control *wbc)
+{
+	struct address_space *mapping = page->mapping;
+	loff_t offset = (loff_t) page->index << PAGE_CACHE_SHIFT;
+	struct inode *inode;
+	unsigned long end_index;
+	char *buffer;
+	int nWritten = 0;
+	unsigned nBytes;
+	j4fs_ctrl ctl;
+	int nErr;
+
+	if(j4fs_panic==1) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return -ENOSPC;
+	}
+
+	J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	if (!mapping) BUG();
+
+	inode = mapping->host;
+
+	if (!inode) BUG();
+
+	if (offset > inode->i_size) {
+		J4FS_T(J4FS_TRACE_FS,
+			("j4fs_writepage at %08x, inode size = %08x!!!\n",
+			(unsigned)(page->index << PAGE_CACHE_SHIFT),
+			(unsigned)inode->i_size));
+		J4FS_T(J4FS_TRACE_FS,
+			("                -> don't care!!\n"));
+		unlock_page(page);
+		return 0;
+	}
+
+	end_index = inode->i_size >> PAGE_CACHE_SHIFT;
+
+	/* easy case */
+	if (page->index < end_index)
+		nBytes = PAGE_CACHE_SIZE;
+	else
+		nBytes = inode->i_size & (PAGE_CACHE_SIZE - 1);
+
+	get_page(page);
+
+	buffer = kmap(page);
+
+	j4fs_GrossLock();
+
+	J4FS_T(J4FS_TRACE_FS,
+		("j4fs_writepage: index=%08x,nBytes=%08x,inode.i_size=%05x\n", (unsigned)(page->index << PAGE_CACHE_SHIFT), nBytes,(int)inode->i_size));
+
+	// write file
+	ctl.buffer=buffer;
+	ctl.count=nBytes;
+	ctl.id=inode->i_ino;
+	ctl.index=offset;
+
+	nErr=fsd_write(&ctl);
+
+	if(nErr==J4FS_RETRY_WRITE) nErr=fsd_write(&ctl);
+
+	J4FS_T(J4FS_TRACE_FS,
+		("j4fs_writepage: index=%08x,nBytes=%08x,inode.i_size=%05x\n", (unsigned)(page->index << PAGE_CACHE_SHIFT), nBytes,(int)inode->i_size));
+
+	j4fs_GrossUnlock();
+
+	kunmap(page);
+	SetPageUptodate(page);
+	unlock_page(page);
+	put_page(page);
+
+	return (nWritten == nBytes) ? 0 : -ENOSPC;
+
+}
+
+#if (J4FS_USE_WRITE_BEGIN_END > 0)
+int j4fs_write_begin(struct file *filp, struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned flags,
+				struct page **pagep, void **fsdata)
+{
+	struct page *pg = NULL;
+	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+	uint32_t offset = pos & (PAGE_CACHE_SIZE - 1);
+	uint32_t to = offset + len;
+
+	int ret = 0;
+	int space_held = 0;
+
+	if(j4fs_panic==1) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return -ENOSPC;
+	}
+
+	J4FS_T(J4FS_TRACE_FS, ("start j4fs_write_begin\n"));
+
+	if(to>PAGE_CACHE_SIZE) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: page size overflow(pos,index,offset,len,to)=(%d,%d,%d,%d,%d)\n",__FUNCTION__,__LINE__,pos,index,offset,len,to));
+		j4fs_panic("page size overflow");
+		return -ENOSPC;
+	}
+
+	/* Get a page */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+	pg = grab_cache_page_write_begin(mapping, index, flags);
+#else
+	pg = __grab_cache_page(mapping, index);
+#endif
+
+	*pagep = pg;
+	if (!pg) {
+		ret =  -ENOMEM;
+		goto out;
+	}
+
+	/* Get fs space */
+	space_held = j4fs_hold_space(PAGE_CACHE_SIZE);
+
+	if (!space_held) {
+		ret = -ENOSPC;
+		goto out;
+	}
+
+	/* Update page if required */
+	if (!Page_Uptodate(pg) && (offset || to < PAGE_CACHE_SIZE))
+		ret = j4fs_readpage_nolock(filp, pg);
+
+	if (ret)
+		goto out;
+
+	/* Happy path return */
+	J4FS_T(J4FS_TRACE_FS, ("end j4fs_write_begin - ok\n"));
+
+	return 0;
+
+out:
+	J4FS_T(J4FS_TRACE_FS, ("end j4fs_write_begin fail returning %d\n", ret));
+
+	if (pg) {
+		unlock_page(pg);
+		page_cache_release(pg);
+	}
+	return ret;
+}
+
+#else
+
+int j4fs_prepare_write(struct file *f, struct page *pg,
+				unsigned offset, unsigned to)
+{
+	if(j4fs_panic==1) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return -ENOSPC;
+	}
+
+	J4FS_T(J4FS_TRACE_FS, ("\nj4fs_prepare_write\n"));
+
+	if(to>PAGE_CACHE_SIZE) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: page size overflow(offset,to)=(%d,%d)\n",__FUNCTION__,__LINE__,offset,to));
+		j4fs_panic("page size overflow");
+		return -ENOSPC;
+	}
+
+	if (!Page_Uptodate(pg) && (offset || to < PAGE_CACHE_SIZE))
+		return j4fs_readpage_nolock(f, pg);
+	return 0;
+}
+#endif
+
+#if (J4FS_USE_WRITE_BEGIN_END > 0)
+int j4fs_write_end(struct file *filp, struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned copied,
+				struct page *pg, void *fsdadata)
+{
+	int ret = 0;
+	void *addr, *kva;
+	uint32_t offset_into_page = pos & (PAGE_CACHE_SIZE - 1);
+
+	if(j4fs_panic==1) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return -ENOSPC;
+	}
+
+	if(offset_into_page+copied > PAGE_CACHE_SIZE) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: page size overflow(offset_into_page,copied)=(%d,%d)\n",__FUNCTION__,__LINE__,offset_into_page, copied));
+		j4fs_panic("page size overflow");
+		return -ENOSPC;
+	}
+
+	kva = kmap(pg);
+	addr = kva + offset_into_page;
+
+	J4FS_T(J4FS_TRACE_FS,
+		("j4fs_write_end addr %x pos %x nBytes %d\n",
+		(unsigned) addr,
+		(int)pos, copied));
+
+	ret = j4fs_file_write(filp, addr, copied, &pos);
+
+	if (ret != copied) {
+		J4FS_T(J4FS_TRACE_ALWAYS, ("j4fs_write_end not same size ret %d  copied %d\n", ret, copied));
+		SetPageError(pg);
+		ClearPageUptodate(pg);
+	} else {
+		SetPageUptodate(pg);
+	}
+
+	kunmap(pg);
+
+	unlock_page(pg);
+	page_cache_release(pg);
+	return ret;
+}
+#else
+
+int j4fs_commit_write(struct file *f, struct page *pg, unsigned offset, unsigned to)
+{
+	void *addr, *kva;
+
+	loff_t pos = (((loff_t) pg->index) << PAGE_CACHE_SHIFT) + offset;
+	int nBytes = to - offset;
+	int nWritten;
+
+	unsigned spos = pos;
+	unsigned saddr;
+
+	if(j4fs_panic==1) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return -ENOSPC;
+	}
+
+	if(offset+nBytes > PAGE_CACHE_SIZE) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: page size overflow(offset,nBytes)=(%d,%d)\n",__FUNCTION__,__LINE__, offset, nBytes));
+		j4fs_panic("page size overflow");
+		return -ENOSPC;
+	}
+
+	kva = kmap(pg);
+	addr = kva + offset;
+
+	saddr = (unsigned) addr;
+
+	J4FS_T(J4FS_TRACE_FS, ("j4fs_commit_write: (addr,pos,nBytes)=(0x%x, 0x%x, 0x%x)\n", saddr, spos, nBytes));
+
+	nWritten = j4fs_file_write(f, addr, nBytes, &pos);
+
+	if (nWritten != nBytes) {
+		J4FS_T(J4FS_TRACE_ALWAYS, ("j4fs_commit_write: (nWritten,nBytes)=(0x%x 0x%x)\n", nWritten, nBytes));
+		SetPageError(pg);
+		ClearPageUptodate(pg);
+	} else {
+		SetPageUptodate(pg);
+	}
+
+	kunmap(pg);
+
+	return nWritten == nBytes ? 0 : nWritten;
+}
+#endif
+
+int j4fs_file_write(struct file *f, const char *buf, size_t n, loff_t *pos)
+{
+	int nWritten, ipos;
+	struct inode *inode;
+	j4fs_ctrl ctl;
+
+	if(j4fs_panic==1) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return -ENOSPC;
+	}
+
+	j4fs_GrossLock();
+
+	inode = f->f_dentry->d_inode;
+
+	if (!S_ISBLK(inode->i_mode) && f->f_flags & O_APPEND)
+		ipos = inode->i_size;
+	else
+		ipos = *pos;
+
+	J4FS_T(J4FS_TRACE_FS,("j4fs_file_write: %zu bytes to ino %ld at %d\n", n, inode->i_ino, ipos));
+
+	// write file
+	ctl.buffer=(BYTE *)buf;
+	ctl.count=n;
+	ctl.id=inode->i_ino;
+	ctl.index=ipos;
+
+	nWritten=fsd_write(&ctl);
+
+	if(nWritten==J4FS_RETRY_WRITE) nWritten=fsd_write(&ctl);
+
+	if(nWritten==J4FS_RETRY_WRITE || error(nWritten))
+	{
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nWritten=0x%x)\n",__FUNCTION__,__LINE__,nWritten));
+		j4fs_GrossUnlock();
+		return -ENOSPC;
+	}
+
+	if (nWritten > 0) {
+		ipos += nWritten;
+		*pos = ipos;
+		if (ipos > inode->i_size) {
+			inode->i_size = ipos;
+			inode->i_blocks = (ipos + 511) >> 9;
+		}
+
+	}
+	j4fs_GrossUnlock();
+	return nWritten == 0 ? -ENOSPC : nWritten;
+}
+
+struct j4fs_inode *j4fs_get_inode(struct super_block *sb, ino_t ino)
+{
+	unsigned int cur_link, latest_matching_offset=0xffffffff;
+	struct j4fs_inode *raw_inode;
+	int nErr;
+	BYTE *buf;
+
+	J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+
+	if(j4fs_panic==1) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		goto error1;
+	}
+
+	if (ino != J4FS_ROOT_INO && ino < J4FS_FIRST_INO) goto Einval;
+
+	if(ino==J4FS_ROOT_INO) goto error1;
+
+	// read j4fs_header in flash which inode number is ino
+	cur_link=device_info.j4fs_offset;
+	while(cur_link!=0xffffffff)
+	{
+		// check the partition range
+		j4fs_check_partition_range(cur_link);
+
+		nErr = FlashDevRead(&device_info, cur_link, J4FS_BASIC_UNIT_SIZE, buf);
+		if (nErr != 0) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+	   		goto error1;
+		}
+
+		raw_inode = (struct j4fs_inode *)buf;
+
+		//This j4fs_header cannot be interpreted. It means there are no files in this partition(this can happen and this is a normal case) or
+		//this j4fs partition is crashed(this should not happen).
+		if(raw_inode->i_type!=J4FS_FILE_TYPE)
+		{
+			// There are no files in this partition or this first j4fs_header is crashed. So, this case should not happen and/or should be repaired.
+			if(cur_link==device_info.j4fs_offset) {
+				j4fs_panic("There are no files in this partition or this first j4fs_header is crashed. So, this case should not happen and/or should be repaired.");
+				goto error1;
+			}
+
+			// This j4fs partition is crashed by some abnormal cause. This should not happen and should be repaired.
+			j4fs_panic("this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		// check whether this file was deleted
+		if ((raw_inode->i_flags&0x1)==((raw_inode->i_flags&0x2)>>1)) {
+			if(raw_inode->i_id==ino) latest_matching_offset=cur_link;
+		}
+
+		cur_link=raw_inode->i_link;
+	}
+
+	if(latest_matching_offset!=0xffffffff)
+	{
+		nErr = FlashDevRead(&device_info, latest_matching_offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (nErr != 0) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+	   		goto error1;
+		}
+
+		raw_inode = (struct j4fs_inode *)buf;
+		return raw_inode;
+	}
+
+Einval:
+	J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: error(bad inode number: %lu)\n",__FUNCTION__,__LINE__,(unsigned long) ino));
+	kfree(buf);
+	return ERR_PTR(-EINVAL);
+
+error1:
+	kfree(buf);
+	return NULL;
+
+}
+
+void j4fs_read_inode (struct inode * inode)
+{
+	struct j4fs_inode_info *ei = J4FS_I(inode);
+	ino_t ino = inode->i_ino;
+	struct j4fs_inode * raw_inode;
+
+	if(j4fs_panic==1) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return;
+	}
+
+	J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	// root inode
+	if(ino==J4FS_ROOT_INO)
+	{
+		inode->i_size = 0;
+		inode->i_mode=S_IFDIR|S_IWUSR|S_IRUGO|S_IXUGO;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29))
+	inode->i_uid=current->fsuid;
+	inode->i_gid=current->fsgid;
+#else
+	inode->i_uid=current->cred->fsuid;
+	inode->i_gid=current->cred->fsgid;
+#endif
+
+		strcpy(ei->i_filename,"/");
+		ei->i_link=device_info.j4fs_offset;
+		ei->i_type=J4FS_FILE_TYPE;
+		ei->i_flags=0x3;
+		ei->i_id=J4FS_ROOT_INO;
+		ei->i_length=0;
+
+		inode->i_op = &j4fs_dir_inode_operations;
+		inode->i_mapping->a_ops = &j4fs_aops;
+		inode->i_fop = &j4fs_dir_operations;
+
+		return;
+	}
+
+	raw_inode = j4fs_get_inode(inode->i_sb, ino);
+
+	if (IS_ERR(raw_inode))
+ 		goto bad_inode;
+
+	inode->i_size = le32_to_cpu(raw_inode->i_length);
+	inode->i_mode=S_IFREG|S_IWUGO|S_IRUGO|S_IXUGO;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29))
+	inode->i_uid=current->fsuid;
+	inode->i_gid=current->fsgid;
+#else
+	inode->i_uid=current->cred->fsuid;
+	inode->i_gid=current->cred->fsgid;
+#endif
+
+	strcpy(ei->i_filename,raw_inode->i_filename);
+	ei->i_link=raw_inode->i_link;
+	ei->i_type=raw_inode->i_type;
+	ei->i_flags=raw_inode->i_flags;
+	ei->i_id=raw_inode->i_id;
+	ei->i_length=raw_inode->i_length;
+
+	if (S_ISREG(inode->i_mode)) {
+		inode->i_op = &j4fs_file_inode_operations;
+		inode->i_mapping->a_ops = &j4fs_aops;
+		inode->i_fop = &j4fs_file_operations;
+	}
+
+	kfree(raw_inode);
+	inode->i_flags |= S_SYNC;
+	return;
+
+bad_inode:
+	make_bad_inode(inode);
+}
+
+// TODO : Consider 'dir'
+ino_t j4fs_inode_by_name(struct inode * dir, struct dentry *dentry)
+{
+	unsigned int cur_link;
+	struct j4fs_inode_info *ei = J4FS_I(dir);
+	struct j4fs_inode *raw_inode;
+	ino_t ino;
+	int nErr;
+	BYTE *buf;
+
+	if(j4fs_panic==1) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return 0;
+	}
+
+	J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+
+	cur_link=ei->i_link;
+	while(cur_link!=0xffffffff)
+	{
+		// check the partition range
+		j4fs_check_partition_range(cur_link);
+
+		nErr = FlashDevRead(&device_info, cur_link, J4FS_BASIC_UNIT_SIZE, buf);
+		if (nErr != 0) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+	   		goto error1;
+		}
+
+		raw_inode = (struct j4fs_inode *) buf;
+
+		//This j4fs_header cannot be interpreted. It means there are no files in this partition(this can happen and this is a normal case) or
+		//this j4fs partition is crashed(this should not happen).
+		if(raw_inode->i_type!=J4FS_FILE_TYPE)
+		{
+			// There are no files in this partition or this first j4fs_header is crashed. So, this case should not happen and/or should be repaired.
+			if(cur_link==ei->i_link) {
+				j4fs_panic("There are no files in this partition or this first j4fs_header is crashed. So, this case should not happen and/or should be repaired.");
+				goto error1;
+			}
+
+			// This j4fs partition is crashed by some abnormal cause. This should not happen and should be repaired.
+			j4fs_panic("this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		// check whether this file was deleted
+		if ((raw_inode->i_flags&0x1)==((raw_inode->i_flags&0x2)>>1)) {
+			if(!strcmp(raw_inode->i_filename, dentry->d_name.name))
+			{
+				ino = raw_inode->i_id;
+				kfree(buf);
+				return ino;
+			}
+		}
+
+		cur_link=raw_inode->i_link;
+	}
+
+error1:
+	kfree(buf);
+
+	return 0;
+
+}
+
+int j4fs_readdir (struct file * filp, void * dirent, filldir_t filldir)
+{
+	unsigned int curoffs, offset, cur_link;
+	struct inode *inode = filp->f_dentry->d_inode;
+	struct j4fs_inode_info *ei = J4FS_I(inode);
+	struct j4fs_inode *raw_inode;
+	int i,j, nErr;
+	BYTE *buf;
+	DWORD valid_offset[128][2];
+	int count=0;
+
+	if(j4fs_panic==1) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return 0;
+	}
+
+	J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+
+	j4fs_GrossLock();
+
+	offset = filp->f_pos;
+
+	if (offset == 0) {
+		nErr=filldir(dirent, ".", 1, offset, filp->f_dentry->d_inode->i_ino, DT_DIR);
+		if (nErr != 0) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+	   		goto error1;
+		}
+		offset++;
+		filp->f_pos++;
+	}
+
+	if (offset == 1) {
+		nErr=filldir(dirent, "..", 2, offset,filp->f_dentry->d_parent->d_inode->i_ino, DT_DIR);
+		if (nErr != 0) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+	   		goto error1;
+		}
+		offset++;
+		filp->f_pos++;
+	}
+
+	curoffs = 1;
+
+	cur_link=ei->i_link;
+	while(cur_link!=0xffffffff)
+	{
+		// check the partition range
+		j4fs_check_partition_range(cur_link);
+
+		nErr = FlashDevRead(&device_info, cur_link, J4FS_BASIC_UNIT_SIZE, buf);
+		if (nErr != 0) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+	   		goto error1;
+		}
+
+		raw_inode = (struct j4fs_inode *) buf;
+
+		//This j4fs_header cannot be interpreted. It means there are no files in this partition(this can happen and this is a normal case) or
+		//this j4fs partition is crashed(this should not happen).
+		if(raw_inode->i_type!=J4FS_FILE_TYPE)
+		{
+			// There are no files in this partition or this first j4fs_header is crashed. So, this case should not happen and/or should be repaired.
+			if(cur_link==ei->i_link) {
+				j4fs_panic("There are no files in this partition or this first j4fs_header is crashed. So, this case should not happen and/or should be repaired.");
+				goto error1;
+			}
+
+			// This j4fs partition is crashed by some abnormal cause. This should not happen and should be repaired.
+			j4fs_panic("this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		// check whether this file was deleted
+		if ((raw_inode->i_flags&0x1)==((raw_inode->i_flags&0x2)>>1)) {
+			valid_offset[count][0]=raw_inode->i_id;
+			valid_offset[count][1]=cur_link;
+			count++;
+		}
+		cur_link=raw_inode->i_link;
+	}
+
+	// TODO: we exclude last object header because last object header can't decide invalidation of old files. Is it right ???
+	// Add files(latest valid object) to directory entry
+	for(i=0;i<count;i++)
+	{
+		for(j=i+1;j<count;j++)
+		{
+			// If inode number is same, valid_offset[i] is invalid
+			if(valid_offset[i][0]==valid_offset[j][0]) break;
+		}
+
+		// Add latest valid object to directory entry
+		if(j==count)
+		{
+			curoffs++;
+			if(curoffs >= offset)
+			{
+				nErr = FlashDevRead(&device_info, valid_offset[i][1], J4FS_BASIC_UNIT_SIZE, buf);
+				if (nErr != 0) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+			   		goto error1;
+				}
+
+				raw_inode = (struct j4fs_inode *) buf;
+
+				nErr=filldir(dirent, raw_inode->i_filename, strlen(raw_inode->i_filename), offset, raw_inode->i_id, DT_REG);
+
+				if(nErr <0) {
+					J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%08x,filename=%s, file length=%d)\n",__FUNCTION__,__LINE__,nErr,raw_inode->i_filename, strlen(raw_inode->i_filename)));
+					goto error1;
+				}
+				else
+				{
+					J4FS_T(J4FS_TRACE_FS,("%s %d: success(filename=%s, file length=%d)\n",__FUNCTION__,__LINE__,raw_inode->i_filename, strlen(raw_inode->i_filename)));
+					offset++;
+					filp->f_pos++;
+				}
+			}
+		}
+	}
+
+error1:
+	kfree(buf);
+	j4fs_GrossUnlock();
+	return 0;
+}
+
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+int j4fs_permission(struct inode *inode, int mask)
+#else
+int j4fs_permission(struct inode *inode, int mask, struct nameidata *nd)
+#endif
+{
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+struct inode *j4fs_iget(struct super_block *sb, unsigned long ino)
+{
+	struct inode * inode;
+	inode = iget_locked(sb, ino);
+
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+
+	if (!(inode->i_state & I_NEW))
+		return inode;
+
+	j4fs_read_inode(inode);
+	unlock_new_inode(inode);
+	return inode;
+}
+#endif
+
+struct dentry *j4fs_lookup(struct inode * dir, struct dentry *dentry, struct nameidata *nd)
+{
+	struct inode * inode;
+	ino_t ino;
+
+	J4FS_T(J4FS_TRACE_FS,("%s %d:(filename=%s)\n",__FUNCTION__,__LINE__,dentry->d_name.name));
+
+	if (dentry->d_name.len > J4FS_NAME_LEN)
+		return ERR_PTR(-ENAMETOOLONG);
+
+	ino = j4fs_inode_by_name(dir, dentry);
+	inode = NULL;
+	if (ino) {
+	#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+		inode = j4fs_iget(dir->i_sb, ino);
+	#else
+		inode = iget(dir->i_sb, ino);
+	#endif
+		if (!inode)
+			return ERR_PTR(-EACCES);
+	}
+	return d_splice_alias(inode, dentry);
+}
+
+struct inode *j4fs_new_inode(struct inode *dir, struct dentry *dentry, int mode)
+{
+	struct super_block *sb;
+	struct inode * inode;
+	struct j4fs_inode_info *ei;
+	unsigned int offset, last_object_offset=0xffffffff, new_object_offset=0xffffffff;
+	struct j4fs_inode *raw_inode=0;
+	ino_t ino = J4FS_FIRST_INO-1;
+	int nErr;
+	BYTE *buf;
+
+#ifdef J4FS_TRANSACTION_LOGGING
+	j4fs_transaction *transaction;
+#endif
+
+	if(j4fs_panic==1) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return NULL;
+	}
+
+	J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	// allocate new inode
+	sb = dir->i_sb;
+	inode = new_inode(sb);
+	if (!inode) {
+		return ERR_PTR(-ENOMEM);
+	}
+
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+
+#ifdef J4FS_TRANSACTION_LOGGING
+	transaction=kmalloc(J4FS_TRANSACTION_SIZE,GFP_NOFS);
+#endif
+
+	ei = J4FS_I(inode);
+
+	if(is_invalid_j4fs_rw_start())
+	{
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error! j4fs_rw_start is invalid(j4fs_rw_start=0x%08x, j4fs_end=0x%08x, ro_j4fs_header_count=0x%08x)\n",
+			__FUNCTION__, __LINE__, j4fs_rw_start, device_info.j4fs_end, ro_j4fs_header_count));
+		j4fs_panic("j4fs_rw_start is invalid");
+		goto error1;
+	}
+
+	// find existing largest inode number
+	// TODO: 1. RO files --> use ro_j4fs_header buffer
+	offset=device_info.j4fs_offset;
+	while(offset!=0xffffffff)
+	{
+		// check the partition range
+		j4fs_check_partition_range(offset);
+
+		// read j4fs_header
+		nErr = FlashDevRead(&device_info, offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (nErr != 0) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+	   		goto error1;
+		}
+
+		raw_inode 	= (struct j4fs_inode *)buf;
+
+		//This j4fs_header cannot be interpreted. It means there are no files in this partition(this can happen and this is a normal case) or
+		//this j4fs partition is crashed(this should not happen).
+		if(raw_inode->i_type!=J4FS_FILE_TYPE)
+		{
+			// There are no files in this partition or this first j4fs_header is crashed. So, this case should not happen and/or should be repaired.
+			if(offset==device_info.j4fs_offset) {
+				j4fs_panic("There are no files in this partition or this first j4fs_header is crashed. So, this case should not happen and/or should be repaired.");
+				goto error1;;
+			}
+
+			// This j4fs partition is crashed by some abnormal cause. This should not happen and should be repaired.
+			j4fs_panic("this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		// check whether this file was deleted
+		if ((raw_inode->i_flags&0x1)==((raw_inode->i_flags&0x2)>>1)) {
+			if(raw_inode->i_id>ino) ino=raw_inode->i_id;
+		}
+
+		last_object_offset=offset;
+		offset=raw_inode->i_link;
+	}
+
+	// set inode number
+	ino++;
+
+	ei->i_id=ino;
+	inode->i_ino = ino;
+	inode->i_mode=S_IFREG|S_IWUGO|S_IRUGO|S_IXUGO;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29))
+	inode->i_uid=current->fsuid;
+	inode->i_gid=current->fsgid;
+#else
+	inode->i_uid=current->cred->fsuid;
+	inode->i_gid=current->cred->fsgid;
+#endif
+	inode->i_op = &j4fs_file_inode_operations;
+	inode->i_mapping->a_ops = &j4fs_aops;
+	inode->i_fop = &j4fs_file_operations;
+	inode->i_flags |= S_SYNC;
+
+	if(last_object_offset!=0xffffffff)
+	{
+		J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+		new_object_offset=last_object_offset;
+		new_object_offset+=J4FS_BASIC_UNIT_SIZE;	// j4fs_header
+		new_object_offset+=raw_inode->i_length;	// data
+		new_object_offset=(new_object_offset+J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE;	// J4FS_BASIC_UNIT_SIZE align
+	}
+	else	//there are no files in this partition, so write first offset of partition
+	{
+		j4fs_panic("There are no files in this partition. There should be one file in j4fs file system at least");
+		goto error1;
+	}
+
+	if((new_object_offset+J4FS_BASIC_UNIT_SIZE-1)>device_info.j4fs_end)
+	{
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: partition size overflow(new_object_offset=0x%08x, j4fs_end=0x%08x)\n",__FUNCTION__,__LINE__,new_object_offset,device_info.j4fs_end));
+		goto error1;
+	}
+
+#ifdef J4FS_TRANSACTION_LOGGING
+	// setting transaction variable
+	memset(transaction,0xff,J4FS_TRANSACTION_SIZE);
+	transaction->magic=J4FS_MAGIC;
+	transaction->sequence=j4fs_next_sequence++;
+	transaction->ino=ino;
+	memcpy(transaction->filename,dentry->d_name.name,dentry->d_name.len);
+	transaction->filename[dentry->d_name.len]=0;
+	transaction->opcode=J4FS_LAST_OBJECT_CREATE_STEP1;
+	transaction->offset=new_object_offset;
+	transaction->b_link=transaction->a_link=0xffffffff;
+	transaction->b_length=transaction->a_length=0;
+
+	nErr = FlashDevWrite(&device_info, j4fs_transaction_next_offset, J4FS_TRANSACTION_SIZE, (BYTE *)transaction);
+
+	if (error(nErr)) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+   		goto error1;
+	}
+
+	j4fs_transaction_next_offset+=J4FS_TRANSACTION_SIZE;
+	if(j4fs_transaction_next_offset>=device_info.j4fs_device_end) j4fs_transaction_next_offset=device_info.j4fs_end;
+#endif
+
+	// add new object(j4fs_header)
+	J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+	memset(buf, 0xff, J4FS_BASIC_UNIT_SIZE);
+	raw_inode = (struct j4fs_inode *)buf;
+	raw_inode->i_link=0xffffffff;
+	raw_inode->i_type=J4FS_FILE_TYPE;
+	raw_inode->i_flags=0x3;
+	raw_inode->i_id=ino;
+	raw_inode->i_length=0;
+	memcpy(raw_inode->i_filename, dentry->d_name.name, dentry->d_name.len);
+	raw_inode->i_filename[dentry->d_name.len]=0;
+
+	nErr = FlashDevWrite(&device_info, new_object_offset, J4FS_BASIC_UNIT_SIZE, buf);
+	if (nErr != 0) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+   		goto error1;
+	}
+
+	// update last_inode
+	if(last_object_offset!=0xffffffff)
+	{
+		J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+		nErr = FlashDevRead(&device_info, last_object_offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (nErr != 0) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+	   		goto error1;
+		}
+
+		raw_inode = (struct j4fs_inode *)buf;
+
+
+	#ifdef J4FS_TRANSACTION_LOGGING
+		// setting transaction variable
+		memset(transaction,0xff,J4FS_TRANSACTION_SIZE);
+		transaction->magic=J4FS_MAGIC;
+		transaction->sequence=j4fs_next_sequence++;
+		transaction->ino=raw_inode->i_id;
+		strcpy(transaction->filename,raw_inode->i_filename);
+		transaction->opcode=J4FS_LAST_OBJECT_CREATE_STEP2;
+		transaction->offset=last_object_offset;
+		transaction->b_link=raw_inode->i_link;
+		transaction->a_link=new_object_offset;
+		transaction->b_length=transaction->a_length=raw_inode->i_length;
+
+		nErr = FlashDevWrite(&device_info, j4fs_transaction_next_offset, J4FS_TRANSACTION_SIZE, (BYTE *)transaction);
+
+		if (error(nErr)) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+	   		goto error1;
+		}
+
+		j4fs_transaction_next_offset+=J4FS_TRANSACTION_SIZE;
+		if(j4fs_transaction_next_offset>=device_info.j4fs_device_end) j4fs_transaction_next_offset=device_info.j4fs_end;
+	#endif
+
+		raw_inode->i_link=new_object_offset;
+
+		nErr = FlashDevWrite(&device_info, last_object_offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (nErr != 0) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+	   		goto error1;
+		}
+	}
+
+	kfree(buf);
+	return inode;
+
+error1:
+	kfree(buf);
+#ifdef J4FS_TRANSACTION_LOGGING
+	kfree(transaction);
+#endif
+	return NULL;
+}
+
+
+/*
+ *	Parent is locked.
+ */
+int j4fs_add_link (struct dentry *dentry, struct inode *inode)
+{
+	// write j4fs_header
+	// TODO
+	J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	return 0;
+
+}
+
+int j4fs_add_nondir(struct dentry *dentry, struct inode *inode)
+{
+	int err;
+
+	J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	err= j4fs_add_link(dentry, inode);
+	if (!err) {
+		d_instantiate(dentry, inode);
+		return 0;
+	}
+	inode_dec_link_count(inode);
+	iput(inode);
+	return err;
+}
+
+/*
+ * By the time this is called, we already have created
+ * the directory cache entry for the new file, but it
+ * is so far negative - it has no inode.
+ * This function is call by do_filp_open()->open_namei()->open_namei_create()->vfs_create()->dir->i_op->create()
+ *
+ * If the create succeeds, we fill in the inode information
+ * with d_instantiate().
+ */
+int j4fs_create (struct inode * dir, struct dentry * dentry, int mode, struct nameidata *nd)
+{
+	struct inode * inode;
+	int err=-1;
+
+	if(j4fs_panic==1) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return err;
+	}
+
+	J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	inode = j4fs_new_inode(dir, dentry, mode);
+
+	if (!IS_ERR(inode)) {
+		inode->i_op = &j4fs_file_inode_operations;
+		inode->i_mapping->a_ops = &j4fs_aops;
+		inode->i_fop = &j4fs_file_operations;
+
+		//mark_inode_dirty(inode);
+		err = j4fs_add_nondir(dentry, inode);
+	}
+	return err;
+}
+
+/* Space holding and freeing is done to ensure we have space available for write_begin/end */
+/* For now we just assume few parallel writes and check against a small number. */
+/* Todo: need to do this with a counter to handle parallel reads better */
+
+int j4fs_hold_space(int size)
+{
+	unsigned int offset, last_object_offset=0xffffffff, new_object_offset=0xffffffff;
+	struct j4fs_inode *raw_inode=NULL;
+	int nErr;
+	BYTE *buf;
+
+	if(j4fs_panic==1) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return 0;
+	}
+
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+
+	// find existing largest inode number
+	offset=device_info.j4fs_offset;
+	while(offset!=0xffffffff)
+	{
+		// check the partition range
+		j4fs_check_partition_range(offset);
+
+		// read j4fs_header
+		nErr = FlashDevRead(&device_info, offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (nErr != 0) {
+			J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+	   		goto error1;
+		}
+
+		raw_inode = (struct j4fs_inode *)buf;
+
+		//This j4fs_header cannot be interpreted. It means there are no files in this partition(this can happen and this is a normal case) or
+		//this j4fs partition is crashed(this should not happen).
+		if(raw_inode->i_type!=J4FS_FILE_TYPE)
+		{
+			// There are no files in this partition or this first j4fs_header is crashed. So, this case should not happen and/or should be repaired.
+			if(offset==device_info.j4fs_offset) {
+				j4fs_panic("There are no files in this partition or this first j4fs_header is crashed. So, this case should not happen and/or should be repaired.");
+				goto error1;
+			}
+
+			// This j4fs partition is crashed by some abnormal cause. This should not happen and should be repaired.
+			j4fs_panic("this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		last_object_offset=offset;
+		offset=raw_inode->i_link;
+	}
+
+	if(last_object_offset!=0xffffffff)
+	{
+		J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+		new_object_offset=last_object_offset;
+		new_object_offset+=J4FS_BASIC_UNIT_SIZE;	// j4fs_header
+		new_object_offset+=raw_inode->i_length;	// data
+		new_object_offset=(new_object_offset+J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE;	// 4096 align
+	}
+
+	kfree(buf);
+	if((new_object_offset+size-1)>device_info.j4fs_end) return 0;
+	else return 1;
+
+error1:
+	kfree(buf);
+	return 0;
+}
+
+int j4fs_fill_super(struct super_block *sb, void *data, int silent)
+{
+	struct j4fs_sb_info * sbi;
+	struct j4fs_super_block * es;
+	struct inode *root;
+	u32 ret;
+
+	J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	sbi = kzalloc(sizeof(*sbi), GFP_NOFS);
+	if (!sbi)
+		return -ENOMEM;
+
+	es=kzalloc(sizeof(*es), GFP_NOFS);
+	if (!es)
+	{
+		kfree(sbi);	
+		return -ENOMEM;
+	}
+
+	sb->s_fs_info = sbi;
+	sbi->s_es = es;
+	sbi->s_first_ino=J4FS_FIRST_INO;
+
+	// Block size is J4FS_BASIC_UNIT_SIZE (4096)
+	sb->s_flags = 0;
+	sb->s_maxbytes = 0xffffffff;
+
+	sb->s_blocksize=J4FS_BASIC_UNIT_SIZE;
+	sb->s_blocksize_bits=J4FS_BASIC_UNIT_SIZE_BITS;
+	sb->s_op = &j4fs_sops;
+	sb->s_xattr = NULL;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+	root=j4fs_iget(sb, J4FS_ROOT_INO);
+#else
+	root = iget(sb, J4FS_ROOT_INO);
+#endif
+
+	sb->s_root = d_alloc_root(root);
+
+	// Set device_info.j4fs_end using STLInfo.nTotalLogScts
+#if defined(J4FS_USE_XSR)
+	ret = STL_IOCtl(0, device_info.device, STL_IOCTL_LOG_SECTS, NULL, sizeof(u32), &tmp, sizeof(u32), &len); 
+#elif defined(J4FS_USE_FSR)
+	ret = FSR_STL_IOCtl(0, device_info.device, FSR_STL_IOCTL_LOG_SECTS, NULL, sizeof(u32), &tmp, sizeof(u32), &len); 
+#endif
+
+#if defined(J4FS_USE_XSR) || defined(J4FS_USE_FSR)
+	if (ret) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(0x%08x)\n",__FUNCTION__,__LINE__,ret));
+		return -EINVAL;
+	}
+
+	// j4fs transaction(1 block) for fils system crash debugging
+	// J4FS_BASIC_UNIT_SIZE align
+	device_info.j4fs_device_end=((tmp/(J4FS_BASIC_UNIT_SIZE/512))*(J4FS_BASIC_UNIT_SIZE/512))*512-1;
+	device_info.j4fs_end=device_info.j4fs_device_end-PHYSICAL_BLOCK_SIZE;
+
+// J4FS for moviNAND merged from ROSSI
+#elif defined(J4FS_USE_MOVI)
+	// j4fs transaction(1 block) for fils system crash debugging
+	// J4FS_BASIC_UNIT_SIZE align
+	device_info.j4fs_device_end=(((J4FS_BLOCK_COUNT * 512)/(J4FS_BASIC_UNIT_SIZE/512))*(J4FS_BASIC_UNIT_SIZE/512))*512-1;
+	device_info.j4fs_end=device_info.j4fs_device_end-PHYSICAL_BLOCK_SIZE;
+#endif
+// J4FS for moviNAND merged from ROSSI
+
+	J4FS_T(J4FS_TRACE_FS,("%s %d: device_info.j4fs_end=0x%08x, device_info.j4fs_device_end=0x%08x\n",__FUNCTION__,__LINE__,device_info.j4fs_end,device_info.j4fs_device_end));
+
+	if (!sb->s_root) {
+		iput(root);
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: error\n",__FUNCTION__,__LINE__));
+		goto failed;
+	}
+
+	sema_init(&device_info.grossLock, 1);
+
+#ifdef J4FS_TRANSACTION_LOGGING
+	ret=fsd_initialize_transaction();
+
+	if (error(ret)) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+   		goto failed;
+	}
+
+	J4FS_T(J4FS_TRACE_FS,("%s %d: j4fs_next_sequence=0x%08x, j4fs_transaction_next_offset=0x%08x\n",__FUNCTION__,__LINE__,j4fs_next_sequence,j4fs_transaction_next_offset));
+#endif
+
+	ret=fsd_reclaim();
+
+	if (error(ret)) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+   		goto failed;
+	}
+
+	return 0;
+
+failed:
+	sb->s_fs_info = NULL;
+	kfree(sbi);
+	kfree(es);
+	return -EINVAL;
+}
+
+
+int j4fs_mount(struct file_system_type *fs_type, int flags, const char *dev_name, void *data)
+{
+	J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	return mount_bdev(fs_type, flags, dev_name, data, j4fs_fill_super);
+}
+
+struct kmem_cache * j4fs_inode_cachep;
+
+struct inode *j4fs_alloc_inode(struct super_block *sb)
+{
+	struct j4fs_inode_info *ei;
+
+	J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	ei = (struct j4fs_inode_info *)kmem_cache_alloc(j4fs_inode_cachep, GFP_NOFS);
+	if (!ei)
+		return NULL;
+
+	ei->vfs_inode.i_version = 1;
+	return &ei->vfs_inode;
+}
+
+void j4fs_destroy_inode(struct inode *inode)
+{
+	J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	kmem_cache_free(j4fs_inode_cachep, J4FS_I(inode));
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+void init_once(void *foo)
+#else
+void init_once(struct kmem_cache * cachep, void *foo)
+#endif
+{
+	struct j4fs_inode_info *ei = (struct j4fs_inode_info *) foo;
+
+	J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	rwlock_init(&ei->i_meta_lock);
+	inode_init_once(&ei->vfs_inode);
+}
+
+int init_inodecache(void)
+{
+	j4fs_inode_cachep = kmem_cache_create("j4fs_inode_cache",
+					     sizeof(struct j4fs_inode_info),
+					     0, (SLAB_RECLAIM_ACCOUNT|
+						SLAB_MEM_SPREAD),
+					     init_once);
+	if (j4fs_inode_cachep == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+void destroy_inodecache(void)
+{
+	kmem_cache_destroy(j4fs_inode_cachep);
+}
+
+struct file_system_type j4fs_fs_type = {
+	.owner		= THIS_MODULE,
+	.name		= "j4fs",
+	.mount		= j4fs_mount,
+	.kill_sb	= kill_block_super,
+	.fs_flags	= FS_REQUIRES_DEV,
+};
+
+extern ssize_t (*lfs_read_module)(struct file *file, const char __user * buffer, size_t count, loff_t *ppos);
+extern ssize_t (*lfs_write_module)(struct file *file, const char __user * buffer, size_t count, loff_t *ppos);
+extern unsigned int j4fs_PORMask;
+extern unsigned int j4fs_PORCount;
+
+ssize_t lfs_read(struct file *file, const char __user * buffer, size_t count, loff_t *ppos)
+{
+	printk("%s %d: (j4fs_PORMask,j4fs_PORCount)=(%x,%d)\n",__FUNCTION__,__LINE__,j4fs_PORMask, j4fs_PORCount);
+	return 0;
+}
+
+ssize_t lfs_write(struct file *file, const char __user * buffer, size_t count, loff_t *ppos)
+{
+	char kbuf[1024];
+
+	if (copy_from_user(&kbuf, buffer, count))
+		return -EFAULT;
+
+	if (sscanf(kbuf, "%x %d", &j4fs_PORMask, &j4fs_PORCount) != 2)
+		return -EINVAL;
+
+	printk("%s %d: (j4fs_PORMask,j4fs_PORCount)=(%x,%d)\n",__FUNCTION__,__LINE__,j4fs_PORMask, j4fs_PORCount);
+	return -EINVAL;
+}
+
+int j4fs_fsync(struct file *file, struct dentry *dentry, int datasync)
+{
+	return 0;
+}
+
+int __init init_j4fs_fs(void)
+{
+	int err;
+	j4fs_ctrl ctl;
+
+	J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	err = init_inodecache();
+	if (err)
+		goto out1;
+
+	J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+        err = register_filesystem(&j4fs_fs_type);
+	if (err)
+		goto out;
+
+#if 0
+	lfs_read_module=lfs_read;
+	lfs_write_module=lfs_write;
+#endif
+	J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	// Initialize j4fs_device_info
+	ctl.scmd=J4FS_INIT;
+	fsd_special(&ctl);
+
+	J4FS_T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	return 0;
+out:
+	destroy_inodecache();
+out1:
+	return err;
+}
+
+void __exit exit_j4fs_fs(void)
+{
+// J4FS for moviNAND merged from ROSSI
+#if defined(J4FS_USE_MOVI)
+	j4fs_ctrl ctl;
+	
+	// Exit j4fs_device_info
+	ctl.scmd=J4FS_EXIT;
+	fsd_special(&ctl);
+#endif
+// J4FS for moviNAND merged from ROSSI
+
+	unregister_filesystem(&j4fs_fs_type);
+	destroy_inodecache();
+}
+
+module_init(init_j4fs_fs)
+module_exit(exit_j4fs_fs)
+
+
+const struct address_space_operations j4fs_aops = {
+	.readpage		= j4fs_readpage,
+	.writepage		= j4fs_writepage,
+#if (J4FS_USE_WRITE_BEGIN_END > 0)
+	.write_begin = j4fs_write_begin,
+	.write_end = j4fs_write_end,
+#else
+	.prepare_write = j4fs_prepare_write,
+	.commit_write = j4fs_commit_write,
+#endif
+};
+
+const struct file_operations j4fs_file_operations = {
+	.read		= do_sync_read,
+	.write		= do_sync_write,
+	.aio_read	= generic_file_aio_read,
+	.aio_write	= generic_file_aio_write,
+	.open		= generic_file_open,
+	.llseek		= generic_file_llseek,
+	.fsync		= j4fs_fsync,
+};
+
+const struct file_operations j4fs_dir_operations = {
+	.llseek		= generic_file_llseek,
+	.read		= generic_read_dir,
+	.readdir		= j4fs_readdir,
+};
+
+const struct inode_operations j4fs_file_inode_operations = {
+	.permission = NULL,
+};
+
+const struct inode_operations j4fs_dir_inode_operations = {
+	.create		= j4fs_create,
+	.lookup		= j4fs_lookup,
+	.permission	= NULL,
+};
+
+const struct super_operations j4fs_sops = {
+	.alloc_inode	= j4fs_alloc_inode,
+	.destroy_inode	= j4fs_destroy_inode,
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 28)
+	.read_inode	= j4fs_read_inode,
+#endif
+};
+
diff -rupN kernel-s2-ics-update7/drivers/samsung/j4fs/llid_kernel.c kernel/drivers/samsung/j4fs/llid_kernel.c
--- kernel-s2-ics-update7/drivers/samsung/j4fs/llid_kernel.c	1970-01-01 07:30:00.000000000 +0730
+++ kernel/drivers/samsung/j4fs/llid_kernel.c	2012-07-27 21:37:57.000000000 +0800
@@ -0,0 +1,237 @@
+/*
+ * llid.c
+ *
+ * Low-Level Interface Driver
+ *
+ * COPYRIGHT(C) Samsung Electronics Co.Ltd. 2009-2010 All Right Reserved.
+ *
+ * 2009.02 - First editing by SungHwan.yun <sunghwan.yun@samsung.com> @LDK@
+ *
+ * 2009.03 - Currently managed by  SungHwan.yun <sunghwan.yun@samsung.com> @LDK@
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include "j4fs.h"
+
+#if defined(J4FS_USE_XSR)
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28))
+#include "./Inc/XsrTypes.h"
+#include "./Inc/STL.h"
+#else
+#include "../../drivers/txsr/Inc/XsrTypes.h"
+#include "../../drivers/txsr/Inc/STL.h"
+#endif
+
+#elif defined(J4FS_USE_FSR)
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28))
+#include "../../fsr/Inc/FSR.h"
+#include "../../fsr/Inc/FSR_STL.h"
+#else
+#include "../fsr/Inc/FSR.h"
+#include "../fsr/Inc/FSR_STL.h"
+#endif
+
+// J4FS for moviNAND merged from ROSSI
+#elif defined(J4FS_USE_MOVI)
+/* j4fs device node name */
+#define J4FS_DEVNAME			"/dev/block/mmcblk0p4"
+static struct file *j4fs_filp;
+// J4FS for moviNAND merged from ROSSI
+
+#else
+'compile error'
+#endif
+
+extern j4fs_device_info device_info;
+extern unsigned int j4fs_traceMask;
+
+/*
+  * Fills the specified buffer with the number of bytes defined by length from the device's absolute physical address
+  * parameters
+  *   offset  : start physical page number
+  *   length  : bytes to write
+  *   buffer  : buffer to write data
+  * return value
+  *   The return code should indicate ERROR (1) or OK(0). If the return code indicates ERROR, the dev_ptr->status field should indicate
+  *   the return error code.
+  */
+int FlashDevRead(j4fs_device_info *dev_ptr, DWORD offset, DWORD length, BYTE *buffer)
+{
+    	DWORD nVol=0;
+	int ret=-1;
+	int part_id=dev_ptr->device;
+
+// J4FS for moviNAND merged from ROSSI
+#ifdef J4FS_USE_MOVI
+	mm_segment_t oldfs;
+#endif
+// J4FS for moviNAND merged from ROSSI
+
+#if defined(J4FS_USE_XSR)
+	ret = STL_Read(nVol, part_id, offset/512, length/512, buffer);
+	if (ret != STL_SUCCESS) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(offset,length,j4fs_end,nErr)=(0x%x,0x%x,0x%x,0x%x)\n",__FUNCTION__,__LINE__,offset,length,device_info.j4fs_end,ret));
+   		return J4FS_FAIL;
+	}
+#elif defined(J4FS_USE_FSR)
+	ret = FSR_STL_Read(nVol, part_id, offset/512, length/512, buffer, FSR_STL_FLAG_DEFAULT);
+	if (ret != FSR_STL_SUCCESS) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(offset,length,j4fs_end,nErr)=(0x%x,0x%x,0x%x,0x%x)\n",__FUNCTION__,__LINE__,offset,length,device_info.j4fs_end,ret));
+   		return J4FS_FAIL;
+	}
+// J4FS for moviNAND merged from ROSSI
+#elif defined(J4FS_USE_MOVI)
+	if (!j4fs_filp) {
+			printk("J4FS not available\n");
+			return J4FS_FAIL;
+		}
+		j4fs_filp->f_flags |= O_NONBLOCK;
+		oldfs = get_fs(); set_fs(get_ds());
+		ret = j4fs_filp->f_op->llseek(j4fs_filp, offset, SEEK_SET);
+		ret = j4fs_filp->f_op->read(j4fs_filp, buffer, length, &j4fs_filp->f_pos);
+		set_fs(oldfs);
+		j4fs_filp->f_flags &= ~O_NONBLOCK;
+		if (ret < 0) {
+			printk(1, "j4fs_filp->read() failed: %d\n", ret);
+			return J4FS_FAIL;
+		}
+// J4FS for moviNAND merged from ROSSI
+#else
+'compile error'
+#endif
+
+	return J4FS_SUCCESS;
+}
+
+/*
+  * This function writes length bytes of data from a specified buffer to the destination address within the device
+  * parameters
+  *   offset  : start physical page number
+  *   length  : bytes to write
+  *   buffer  : buffer to write data
+  * return value
+  *   The return code should indicate ERROR (1) or OK(0). If the return code indicates ERROR, the dev_ptr->status field should indicate
+  *   the return error code.
+  */
+int FlashDevWrite(j4fs_device_info *dev_ptr, DWORD offset, DWORD length, BYTE *buffer)
+{
+    	DWORD nVol=0;
+	int ret=-1;
+	int part_id=dev_ptr->device;
+
+// J4FS for moviNAND merged from ROSSI
+#ifdef J4FS_USE_MOVI
+	mm_segment_t oldfs;
+#endif
+// J4FS for moviNAND merged from ROSSI
+
+#if defined(J4FS_USE_XSR)
+	ret = STL_Write(nVol, part_id, offset/512, length/512, buffer);
+	if (ret != STL_SUCCESS) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(offset,length,j4fs_end,nErr)=(0x%x,0x%x,0x%x,0x%x)\n",__FUNCTION__,__LINE__,offset,length,device_info.j4fs_end,ret));
+   		return J4FS_FAIL;
+	}
+#elif defined(J4FS_USE_FSR)
+	ret = FSR_STL_Write(nVol, part_id, offset/512, length/512, buffer, FSR_STL_FLAG_DEFAULT);
+	if (ret != FSR_STL_SUCCESS) {
+		J4FS_T(J4FS_TRACE_ALWAYS,("%s %d: Error(offset,length,j4fs_end,nErr)=(0x%x,0x%x,0x%x,0x%x)\n",__FUNCTION__,__LINE__,offset,length,device_info.j4fs_end,ret));
+   		return J4FS_FAIL;
+	}
+// J4FS for moviNAND merged from ROSSI
+#elif defined(J4FS_USE_MOVI)
+	if (!j4fs_filp) {
+			printk("J4FS not available\n");
+			return J4FS_FAIL;
+	}
+	j4fs_filp->f_flags |= O_NONBLOCK;
+	oldfs = get_fs(); set_fs(get_ds());
+	ret = j4fs_filp->f_op->llseek(j4fs_filp, offset, SEEK_SET);
+	ret = j4fs_filp->f_op->write(j4fs_filp, buffer, length, &j4fs_filp->f_pos);
+	set_fs(oldfs);
+	j4fs_filp->f_flags &= ~O_NONBLOCK;
+	if (ret < 0) {
+		printk(1, "j4fs_filp->write() failed: %d\n", ret);
+		return J4FS_FAIL;
+	}
+// J4FS for moviNAND merged from ROSSI
+#else
+'compile error'
+#endif
+
+	return J4FS_SUCCESS;
+}
+
+/*
+  * In order to reuse the flash media, an erase command must be provided for the FSD. This command erases a single flash erase-block beginning
+  * at the address specified by the aux field in the DEVICE_INFO structure. The blocksize field of the DEVICE_INFO structure is used to force the aux ptr
+  * to a block boundary.
+  * parameters
+  *   dev_ptr->aux : start block address to be erased
+  */
+int FlashDevErase(j4fs_device_info *dev_ptr)
+{
+	// TODO
+	return J4FS_SUCCESS;
+}
+
+int FlashDevSpecial(j4fs_device_info *dev_ptr, DWORD scmd)
+{
+	switch(scmd)
+	{
+		case J4FS_INIT:
+			// Initialize the internal FSD structures to use a device
+			FlashDevMount();
+
+			break;
+
+		case J4FS_GET_INFO:
+			break;
+
+// J4FS for moviNAND merged from ROSSI
+		case J4FS_EXIT:
+			FlashDevUnmount();
+// J4FS for moviNAND merged from ROSSI
+
+		default:
+			break;
+	}
+
+	return J4FS_SUCCESS;
+}
+
+int FlashDevMount()
+{
+	DWORD media_status_table_size=1;		//  Media Status Table occupys 1 block
+
+// J4FS for moviNAND merged from ROSSI
+#ifdef J4FS_USE_MOVI
+	j4fs_filp = filp_open(J4FS_DEVNAME, O_RDWR|O_SYNC, 0);
+	if (IS_ERR(j4fs_filp)) {
+		printk("FlashDevMount : filp_open() failed~!: %ld\n", PTR_ERR(j4fs_filp));
+		return J4FS_FAIL;
+	}
+	printk("FlashDevMount : filp_open() OK....!\n");
+#endif
+// J4FS for moviNAND merged from ROSSI
+
+	device_info.device=J4FS_PARTITION_ID;
+	device_info.blocksize=PHYSICAL_BLOCK_SIZE;
+	device_info.pagesize=PHYSICAL_PAGE_SIZE;
+	device_info.j4fs_offset=media_status_table_size*device_info.blocksize;	 // j4fs_offset follows the Media Status Table.
+	return J4FS_SUCCESS;
+}
+
+int FlashDevUnmount()
+{
+// ROSSI Projecct(hyunkwon.kim) 2010.09.06 Add J4FS for Parameter Infomation
+#ifdef J4FS_USE_MOVI
+	filp_close(j4fs_filp, NULL);
+	printk("FlashDevUnmount : filp_close() OK....!\n");
+#endif
+// ROSSI Projecct(hyunkwon.kim) 2010.09.06 End
+
+	return J4FS_SUCCESS;
+}
diff -rupN kernel-s2-ics-update7/drivers/samsung/j4fs/Makefile kernel/drivers/samsung/j4fs/Makefile
--- kernel-s2-ics-update7/drivers/samsung/j4fs/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ kernel/drivers/samsung/j4fs/Makefile	2012-07-27 21:37:57.000000000 +0800
@@ -0,0 +1,31 @@
+##############################################################################
+# COPYRIGHT(C)	: Samsung Electronics Co.Ltd, 2006-2011 ALL RIGHTS RESERVED
+# 2009.02 - Currently managed by  JongMinKim <jm45.kim@samsung.com> , SungHwanYun <sunghwan.yun@samsung.com>
+##############################################################################
+# VERSION&DATE	: Version 1.00	2009/02
+##############################################################################
+
+MOD_NAME = j4fs
+
+ifneq ($(KERNELRELEASE), )
+
+EXTRA_CFLAGS +=  -I$(PRJROOT)/modules/include -I$(KDIR)/drivers/tfsr/Inc -I$(KDIR)/include -I$(KDIR)/include/linux -I$(KDIR)/include/asm -D__KERNEL
+
+obj-m := $(MOD_NAME).o
+
+$(MOD_NAME)-y := j4fs_kernel.o llid_kernel.o fsd_common.o
+
+else
+
+all:
+	@$(MAKE) -C $(KDIR) \
+		SUBDIRS=$(CURDIR) modules
+
+clean:
+	rm -f *.o *.ko *.mod.c *~ .*.cmd
+
+install:
+	@$(MAKE) --no-print-directory -C $(KDIR) \
+		SUBDIRS=$(CURDIR) modules_install
+
+endif
diff -rupN kernel-s2-ics-update7/drivers/samsung/Kconfig kernel/drivers/samsung/Kconfig
--- kernel-s2-ics-update7/drivers/samsung/Kconfig	2012-07-23 16:38:04.000000000 +0800
+++ kernel/drivers/samsung/Kconfig	2012-07-27 21:37:57.000000000 +0800
@@ -16,6 +16,13 @@ menuconfig FM_RADIO
 	help
 	  Say Y to enable FM Radio Driver
 
+menuconfig J4FS
+	tristate "Samsung J4FS support"
+	depends on SAMSUNG_MODULES
+	default m
+	help
+	  Say Y to enable Samsung J4FS support.
+
 menuconfig FM_SI4709
 	tristate "Si4709 FM radio"
 	depends on FM_RADIO
diff -rupN kernel-s2-ics-update7/drivers/samsung/Makefile kernel/drivers/samsung/Makefile
--- kernel-s2-ics-update7/drivers/samsung/Makefile	2012-07-23 16:38:04.000000000 +0800
+++ kernel/drivers/samsung/Makefile	2012-07-27 21:37:57.000000000 +0800
@@ -4,4 +4,5 @@
 
 # Object files in subdirectories
 
+obj-$(CONFIG_J4FS)		+= j4fs/
 obj-$(CONFIG_FM_RADIO)		+= fm_si4709/
diff -rupN kernel-s2-ics-update7/drivers/video/samsung/Makefile kernel/drivers/video/samsung/Makefile
--- kernel-s2-ics-update7/drivers/video/samsung/Makefile	2012-07-23 16:38:06.000000000 +0800
+++ kernel/drivers/video/samsung/Makefile	2012-07-27 21:37:57.000000000 +0800
@@ -1,3 +1,4 @@
+subdir-ccflags-y += -fno-inline-functions
 #
 # Makefile for the s3c framebuffer driver
 #
diff -rupN kernel-s2-ics-update7/drivers/video/samsung/mdnie_table_q1.h kernel/drivers/video/samsung/mdnie_table_q1.h
--- kernel-s2-ics-update7/drivers/video/samsung/mdnie_table_q1.h	2012-07-23 16:38:06.000000000 +0800
+++ kernel/drivers/video/samsung/mdnie_table_q1.h	2012-07-27 21:37:57.000000000 +0800
@@ -11,11 +11,11 @@ static const unsigned short tune_dynamic
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x03ff, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x00a0, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -65,11 +65,11 @@ static const unsigned short tune_dynamic
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0030, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x00a0, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -119,11 +119,11 @@ static const unsigned short tune_dynamic
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x03ff, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x00a0, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -173,11 +173,11 @@ static const unsigned short tune_dynamic
 	0x002d, 0x19ff,	/*DNR dirnumTh decon7Th */
 	0x002e, 0xff16,	/*DNR decon5Th maskTh */
 	0x002f, 0x0000,	/*DNR blTh */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x03ff, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0100, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -380,9 +380,9 @@ static const unsigned short tune_movie_v
 	0x002d, 0x19ff, /*DNR dirnumTh decon7Th */
 	0x002e, 0xff16, /*DNR decon5Th maskTh */
 	0x002f, 0x0000, /*DNR blTh */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0000, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0030, /*CS GAIN */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xa4aa, /*gc R */
@@ -433,11 +433,11 @@ static const unsigned short tune_standar
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0300, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0030, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -487,11 +487,11 @@ static const unsigned short tune_standar
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0000, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0030, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -541,11 +541,11 @@ static const unsigned short tune_standar
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0300, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0030, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -595,11 +595,11 @@ static const unsigned short tune_standar
 	0x002d, 0x19ff, /*DNR dirnumTh decon7Th */
 	0x002e, 0xff16, /*DNR decon5Th maskTh */
 	0x002f, 0x0000, /*DNR blTh */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x03f8, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x00a0, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -649,11 +649,11 @@ static const unsigned short tune_natural
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0300, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0180, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xa4aa, /*gc R */
 	0x00ca, 0xd5fe, /*rm R */
@@ -703,11 +703,11 @@ static const unsigned short tune_natural
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0000, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0180, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xa4aa, /*gc R */
 	0x00ca, 0xd5fe, /*rm R */
@@ -757,11 +757,11 @@ static const unsigned short tune_natural
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0300, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0180, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xa4aa, /*gc R */
 	0x00ca, 0xd5fe, /*rm R */
@@ -811,11 +811,11 @@ static const unsigned short tune_natural
 	0x002d, 0x19ff, /*DNR dirnumTh decon7Th */
 	0x002e, 0xff16, /*DNR decon5Th maskTh */
 	0x002f, 0x0000, /*DNR blTh */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x03f8, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0180, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xa4aa, /*gc R */
 	0x00ca, 0xd5fe, /*rm R */
@@ -865,11 +865,11 @@ static const unsigned short tune_camera[
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0030, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0030, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -919,11 +919,11 @@ static const unsigned short tune_camera_
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0030, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0030, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x0054, 0x6050, /*OVE LIGHTNESS CHROMA */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
diff -rupN kernel-s2-ics-update7/drivers/video/samsung/mdnie_table_u1.h kernel/drivers/video/samsung/mdnie_table_u1.h
--- kernel-s2-ics-update7/drivers/video/samsung/mdnie_table_u1.h	2012-07-23 16:38:07.000000000 +0800
+++ kernel/drivers/video/samsung/mdnie_table_u1.h	2012-07-27 21:37:57.000000000 +0800
@@ -11,11 +11,11 @@ static const unsigned short tune_dynamic
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003A, 0x000D, /*HDTR DE CS */
-	0x003B, 0x03ff, /*DE SHARPNESS */
-	0x003C, 0x0000, /*NOISE LEVEL */
+	0x003A, 0x0009, /*HDTR DE CS */
+
+
 	0x003F, 0x012c, /*CS GAIN  */
-	0x0042, 0x0020, /*DE TH (MAX DIFF) */
+
 	0x0049, 0x0400, /*pcc skin */
 	0x004a, 0x7a00,
 	0x004b, 0x008f,
@@ -69,12 +69,11 @@ static const unsigned short tune_dynamic
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003A, 0x000d, /*HDTR DE_off CS : de on = d ,  de off = 9 */
-	0x003B, 0x0001, /*DE SHARPNESS(0~1023)  off */
-	0x003C, 0x0000, /*NOISE LEVEL */
+	0x003A, 0x0009, /*HDTR DE_off CS : de on = d ,  de off = 9 */
+
+
 	0x003F, 0x012c, /*CS GAIN 300 */
-	0x003B, 0x0001, /*DE SHARPNESS(0~1023)  off */
-	0x0042, 0x0030, /*DE TH (MAX DIFF) */
+
 	0x004d, 0x0100, /*pcc strength */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
@@ -125,11 +124,11 @@ static const unsigned short tune_dynamic
 	0x002d, 0x1908, /*DNR bypass 0x0a08 */
 	0x002e, 0x1005, /*DNR bypass 0x1010 */
 	0x002f, 0x0400, /*DNR bypass 0x0400 */
-	0x003A, 0x000D, /*HDTR DE CS  de on = d ,  de off = 9 */
-	0x003B, 0x03ff, /*DE SHARPNESS */
-	0x003C, 0x0000, /*NOISE LEVEL */
+	0x003A, 0x0009, /*HDTR DE CS  de on = d ,  de off = 9 */
+
+
 	0x003F, 0x012c, /*CS GAIN  */
-	0x0042, 0x0020, /*DE TH (MAX DIFF) */
+
 	0x0049, 0x0400, /*pcc skin */
 	0x004a, 0x7a00, /*7300 */
 	0x004b, 0x008F, /*008f */
@@ -183,11 +182,11 @@ static const unsigned short tune_dynamic
 	0x002d, 0x19ff, /*DNR dirnumTh decon7Th */
 	0x002e, 0xff16, /*DNR decon5Th maskTh */
 	0x002f, 0x0000, /*DNR blTh */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x03ff, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003A, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0100, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -237,11 +236,11 @@ static const unsigned short tune_movie_g
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003A, 0x000D, /*HDTR DE CS */
-	0x003B, 0x0001, /*DE SHARPNESS */
-	0x003C, 0x0000, /*NOISE LEVEL */
-	0x003F, 0x0032, /*CS GAIN 300 */
-	0x0042, 0x003f, /*DE TH (MAX DIFF) */
+	0x003A, 0x0009, /*HDTR DE CS */
+
+
+	0x003F, 0x000f, /*CS GAIN 300 */
+
 	0x0049, 0x0400, /*pcc skin */
 	0x004a, 0x7a00,
 	0x004b, 0x008f,
@@ -295,11 +294,11 @@ static const unsigned short tune_movie_u
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003A, 0x000d, /*HDTR DE_off CS : de on = d ,  de off = 9 */
-	0x003B, 0x0001, /*DE SHARPNESS(0~1023)  off */
-	0x003C, 0x0000, /*NOISE LEVEL */
-	0x003F, 0x0032, /*CS GAIN 50 */
-	0x0042, 0x0030, /*DE TH (MAX DIFF) */
+	0x003A, 0x0009, /*HDTR DE_off CS : de on = d ,  de off = 9 */
+
+
+	0x003F, 0x000f, /*CS GAIN 50 */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xb6bc, /*gc R */
 	0x00ca, 0xd4ff, /*rm R */
@@ -349,11 +348,11 @@ static const unsigned short tune_movie_v
 	0x002d, 0x1908, /*DNR bypass 0x0a08 */
 	0x002e, 0x1005, /*DNR bypass 0x1010 */
 	0x002f, 0x0400, /*DNR bypass 0x0400 */
-	0x003A, 0x000D, /*HDTR DE CS  de on = d ,  de off = 9 */
-	0x003B, 0x0001, /*DE SHARPNESS */
-	0x003C, 0x0000, /*NOISE LEVEL */
-	0x003F, 0x0032, /*CS GAIN 300 */
-	0x0042, 0x003f, /*DE TH (MAX DIFF) */
+	0x003A, 0x0009, /*HDTR DE CS  de on = d ,  de off = 9 */
+
+
+	0x003F, 0x000f, /*CS GAIN 300 */
+
 	0x0049, 0x0400, /*pcc skin */
 	0x004a, 0x7a00, /*7300 */
 	0x004b, 0x008F, /*008f */
@@ -407,10 +406,10 @@ static const unsigned short tune_movie_v
 	0x002d, 0x19ff, /*DNR dirnumTh decon7Th */
 	0x002e, 0xff16, /*DNR decon5Th maskTh */
 	0x002f, 0x0000, /*DNR blTh */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0000, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
-	0x003f, 0x0030, /*CS GAIN */
+	0x003A, 0x0009, /*HDTR DE CS */
+
+
+	0x003F, 0x000f, /*CS GAIN */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xb6bc, /*gc R */
 	0x00ca, 0xd4ff, /*rm R */
@@ -461,15 +460,15 @@ static const unsigned short tune_standar
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003A, 0x000D, /*HDTR DE CS */
-	0x003B, 0x03ff, /*DE SHARPNESS */
-	0x003C, 0x0000, /*NOISE LEVEL */
-	0x003F, 0x0032, /*CS GAIN  */
-	0x0042, 0x0020, /*DE TH (MAX DIFF) */
+	0x003A, 0x0009, /*HDTR DE CS */
+
+
+	0x003F, 0x000f, /*CS GAIN  */
+
 	0x0049, 0x0400, /*pcc skin */
 	0x004a, 0x7a00,
 	0x004b, 0x008f,
-	0x004d, 0x0100, /*pcc strength */
+	0x004d, 0x0000, /*pcc strength */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -519,11 +518,11 @@ static const unsigned short tune_standar
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000,	/*DNR bypass 0x1010 */
 	0x002f, 0x0fff,	/*DNR bypass 0x0400 */
-	0x003A, 0x000d,	/*HDTR DE_off CS : de on = d ,  de off = 9 */
-	0x003B, 0x0001,	/*DE SHARPNESS(0~1023)  off */
-	0x003C, 0x0000,	/*NOISE LEVEL */
-	0x003F, 0x001e,	/*CS GAIN 30 */
-	0x0042, 0x0030,	/*DE TH (MAX DIFF) */
+	0x003A, 0x0009,	/*HDTR DE_off CS : de on = d ,  de off = 9 */
+
+
+	0x003F, 0x000f,	/*CS GAIN 30 */
+
 	0x00c8, 0x0000,	/*kb R	SCR */
 	0x00c9, 0x0000,	/*gc R */
 	0x00ca, 0xffff,	/*rm R */
@@ -573,15 +572,15 @@ static const unsigned short tune_standar
 	0x002d, 0x1908, /*DNR bypass 0x0a08 */
 	0x002e, 0x1005, /*DNR bypass 0x1010 */
 	0x002f, 0x0400, /*DNR bypass 0x0400 */
-	0x003A, 0x000D, /*HDTR DE CS  de on = d ,  de off = 9 */
-	0x003B, 0x03ff, /*DE SHARPNESS */
-	0x003C, 0x0000, /*NOISE LEVEL */
-	0x003F, 0x0032, /*CS GAIN  */
-	0x0042, 0x0020, /*DE TH (MAX DIFF) */
+	0x003A, 0x0009, /*HDTR DE CS  de on = d ,  de off = 9 */
+
+
+	0x003F, 0x000f, /*CS GAIN  */
+
 	0x0049, 0x0400, /*pcc skin */
 	0x004a, 0x7a00, /*7300 */
 	0x004b, 0x008F, /*008f */
-	0x004d, 0x0100, /*pcc strength */
+	0x004d, 0x0000, /*pcc strength */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -631,11 +630,11 @@ static const unsigned short tune_standar
 	0x002d, 0x19ff, /*DNR dirnumTh decon7Th */
 	0x002e, 0xff16, /*DNR decon5Th maskTh */
 	0x002f, 0x0000, /*DNR blTh */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x03f8, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
-	0x003f, 0x00a0, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+	0x003A, 0x0009, /*HDTR DE CS */
+
+
+	0x003F, 0x000f, /*CS GAIN */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -685,15 +684,15 @@ static const unsigned short tune_natural
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003A, 0x000D, /*HDTR DE CS */
-	0x003B, 0x03ff, /*DE SHARPNESS */
-	0x003C, 0x0000, /*NOISE LEVEL */
+	0x003A, 0x0009, /*HDTR DE CS */
+
+
 	0x003F, 0x0180, /*CS GAIN  */
-	0x0042, 0x0020, /*DE TH (MAX DIFF) */
+
 	0x0049, 0x0400, /*pcc skin */
 	0x004a, 0x7a00,
 	0x004b, 0x008f,
-	0x004d, 0x0100, /*pcc strength */
+	0x004d, 0x0000, /*pcc strength */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xb6bc, /*gc R */
 	0x00ca, 0xd4ff, /*rm R */
@@ -743,11 +742,11 @@ static const unsigned short tune_natural
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003A, 0x000d, /*HDTR DE_off CS : de on = d ,  de off = 9 */
-	0x003B, 0x0001, /*DE SHARPNESS(0~1023)  off */
-	0x003C, 0x0000, /*NOISE LEVEL */
+	0x003A, 0x0009, /*HDTR DE_off CS : de on = d ,  de off = 9 */
+
+
 	0x003F, 0x0180, /*CS GAIN 30 */
-	0x0042, 0x0030, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xb6bc, /*gc R */
 	0x00ca, 0xd4ff, /*rm R */
@@ -797,15 +796,15 @@ static const unsigned short tune_natural
 	0x002d, 0x1908, /*DNR bypass 0x0a08 */
 	0x002e, 0x1005, /*DNR bypass 0x1010 */
 	0x002f, 0x0400, /*DNR bypass 0x0400 */
-	0x003A, 0x000D, /*HDTR DE CS  de on = d ,  de off = 9 */
-	0x003B, 0x03ff, /*DE SHARPNESS */
-	0x003C, 0x0000, /*NOISE LEVEL */
+	0x003A, 0x0009, /*HDTR DE CS  de on = d ,  de off = 9 */
+
+
 	0x003F, 0x0180, /*CS GAIN  */
-	0x0042, 0x0020, /*DE TH (MAX DIFF) */
+
 	0x0049, 0x0400, /*pcc skin */
 	0x004a, 0x7a00, /*7300 */
 	0x004b, 0x008F, /*008f */
-	0x004d, 0x0100, /*pcc strength */
+	0x004d, 0x0000, /*pcc strength */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xb6bc, /*gc R */
 	0x00ca, 0xd4ff, /*rm R */
@@ -855,11 +854,11 @@ static const unsigned short tune_natural
 	0x002d, 0x19ff, /*DNR dirnumTh decon7Th */
 	0x002e, 0xff16, /*DNR decon5Th maskTh */
 	0x002f, 0x0000, /*DNR blTh */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x03f8, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003A, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0180, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xb6bc, /*gc R */
 	0x00ca, 0xd4ff, /*rm R */
@@ -910,10 +909,10 @@ static const unsigned short tune_camera[
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
 	0x003A, 0x0009, /*HDTR (DE off)(CS only 9) */
-	0x003B, 0x0000, /*DE SHARPNESS */
-	0x003C, 0x0000, /*NOISE LEVEL */
+
+
 	0x003F, 0x0000, /*CS GAIN */
-	0x0042, 0x003f, /*DE TH (MAX DIFF) */
+
 	0x0028, 0x0000, /*Register Mask */
 	/*end */
 	END_SEQ, 0x0000,
@@ -926,11 +925,11 @@ static const unsigned short tune_camera_
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003A, 0x000D, /*HDTR DE CS */
-	0x003B, 0x03ff, /*DE SHARPNESS */
-	0x003C, 0x0000, /*NOISE LEVEL */
+	0x003A, 0x0009, /*HDTR DE CS */
+
+
 	0x003F, 0x0100, /*CS GAIN */
-	0x0042, 0x003f, /*DE TH (MAX DIFF) */
+
 	0x0049, 0x0400, /*pcc skin */
 	0x004a, 0x7300,
 	0x004b, 0x008f,
diff -rupN kernel-s2-ics-update7/drivers/video/samsung/s3cfb.h kernel/drivers/video/samsung/s3cfb.h
--- kernel-s2-ics-update7/drivers/video/samsung/s3cfb.h	2012-07-23 16:38:06.000000000 +0800
+++ kernel/drivers/video/samsung/s3cfb.h	2012-07-27 21:37:57.000000000 +0800
@@ -258,7 +258,8 @@ struct s3cfb_user_chroma {
 #define S3CFB_SET_ALPHA_MODE		_IOW('F', 313, unsigned int)
 
 extern struct fb_ops			s3cfb_ops;
-extern inline struct s3cfb_global	*get_fimd_global(int id);
+//extern inline struct s3cfb_global	*get_fimd_global(int id);
+extern struct s3cfb_global     *get_fimd_global(int id);
 
 /* S3CFB */
 extern struct s3c_platform_fb *to_fb_plat(struct device *dev);
diff -rupN kernel-s2-ics-update7/include/linux/sched.h kernel/include/linux/sched.h
--- kernel-s2-ics-update7/include/linux/sched.h	2012-07-23 16:37:51.000000000 +0800
+++ kernel/include/linux/sched.h	2012-07-27 21:37:57.000000000 +0800
@@ -902,6 +902,7 @@ struct sched_group_power {
 	 * single CPU.
 	 */
 	unsigned int power, power_orig;
+	unsigned long next_update;
 };
 
 struct sched_group {
diff -rupN kernel-s2-ics-update7/init/Kconfig kernel/init/Kconfig
--- kernel-s2-ics-update7/init/Kconfig	2012-07-23 16:38:10.000000000 +0800
+++ kernel/init/Kconfig	2012-07-27 21:37:57.000000000 +0800
@@ -968,7 +968,8 @@ config KALLSYMS
 
 config KALLSYMS_ALL
 	bool "Include all symbols in kallsyms"
-	depends on DEBUG_KERNEL && KALLSYMS
+	#depends on DEBUG_KERNEL && KALLSYMS
+	depends on KALLSYMS
 	help
 	   Normally kallsyms only contains the symbols of functions for nicer
 	   OOPS messages and backtraces (i.e., symbols from the text and inittext
diff -rupN kernel-s2-ics-update7/kernel/sched_fair.c kernel/kernel/sched_fair.c
--- kernel-s2-ics-update7/kernel/sched_fair.c	2012-07-23 16:37:40.000000000 +0800
+++ kernel/kernel/sched_fair.c	2012-07-27 21:37:57.000000000 +0800
@@ -91,6 +91,8 @@ unsigned int __read_mostly sysctl_sched_
 
 static const struct sched_class fair_sched_class;
 
+static unsigned long __read_mostly max_load_balance_interval = HZ/10;
+
 /**************************************************************
  * CFS operations on generic schedulable entities:
  */
@@ -2655,6 +2657,11 @@ static void update_group_power(struct sc
 	struct sched_domain *child = sd->child;
 	struct sched_group *group, *sdg = sd->groups;
 	unsigned long power;
+	unsigned long interval;
+
+	interval = msecs_to_jiffies(sd->balance_interval);
+	interval = clamp(interval, 1UL, max_load_balance_interval);
+	sdg->sgp->next_update = jiffies + interval;
 
 	if (!child) {
 		update_cpu_power(sd, cpu);
@@ -2762,12 +2769,15 @@ static inline void update_sg_lb_stats(st
 	 * domains. In the newly idle case, we will allow all the cpu's
 	 * to do the newly idle load balance.
 	 */
-	if (idle != CPU_NEWLY_IDLE && local_group) {
-		if (balance_cpu != this_cpu) {
-			*balance = 0;
-			return;
-		}
-		update_group_power(sd, this_cpu);
+	if (local_group) {
+		if (idle != CPU_NEWLY_IDLE) {
+			if (balance_cpu != this_cpu) {
+				*balance = 0;
+				return;
+			}
+			update_group_power(sd, this_cpu);
+		} else if (time_after_eq(jiffies, group->sgp->next_update))
+			update_group_power(sd, this_cpu);
 	}
 
 	/* Adjust by relative CPU power of the group */
@@ -3867,8 +3877,6 @@ void select_nohz_load_balancer(int stop_
 
 static DEFINE_SPINLOCK(balancing);
 
-static unsigned long __read_mostly max_load_balance_interval = HZ/10;
-
 /*
  * Scale the max load_balance interval with the number of CPUs in the system.
  * This trades load-balance latency on larger machines for less cross talk.
diff -rupN kernel-s2-ics-update7/kernel/sched_features.h kernel/kernel/sched_features.h
--- kernel-s2-ics-update7/kernel/sched_features.h	2012-07-23 16:37:40.000000000 +0800
+++ kernel/kernel/sched_features.h	2012-07-27 21:37:57.000000000 +0800
@@ -47,7 +47,7 @@ SCHED_FEAT(CACHE_HOT_BUDDY, 1)
 /*
  * Use arch dependent cpu power functions
  */
-SCHED_FEAT(ARCH_POWER, 0)
+SCHED_FEAT(ARCH_POWER, 1)
 
 SCHED_FEAT(HRTICK, 0)
 SCHED_FEAT(DOUBLE_TICK, 0)
diff -rupN kernel-s2-ics-update7/lib/Kconfig.debug kernel/lib/Kconfig.debug
--- kernel-s2-ics-update7/lib/Kconfig.debug	2012-07-23 16:38:08.000000000 +0800
+++ kernel/lib/Kconfig.debug	2012-07-27 21:37:57.000000000 +0800
@@ -296,7 +296,8 @@ config BOOTPARAM_HUNG_TASK_PANIC_VALUE
 
 config SCHED_DEBUG
 	bool "Collect scheduler debugging info"
-	depends on DEBUG_KERNEL && PROC_FS
+	#depends on DEBUG_KERNEL && PROC_FS
+	depends on PROC_FS
 	default y
 	help
 	  If you say Y here, the /proc/sched_debug file will be provided
diff -rupN kernel-s2-ics-update7/Makefile kernel/Makefile
--- kernel-s2-ics-update7/Makefile	2012-07-25 17:10:07.000000000 +0800
+++ kernel/Makefile	2012-07-28 13:07:06.000000000 +0800
@@ -193,7 +193,8 @@ SUBARCH := $(shell uname -m | sed -e s/i
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 export KBUILD_BUILDHOST := $(SUBARCH)
 ARCH		?= arm
-CROSS_COMPILE	?= /opt/toolchains/arm-eabi-4.4.3/bin/arm-eabi-
+#CROSS_COMPILE	?= /opt/toolchains/arm-eabi-4.4.3/bin/arm-eabi-
+CROSS_COMPILE   ?= /home/kernel/android-toolchain-eabi-4-4/bin/arm-eabi-
 
 # Architecture as present in compile.h
 UTS_MACHINE 	:= $(ARCH)
@@ -368,7 +369,15 @@ KBUILD_CFLAGS   := -Wall -Wundef -Wstric
 		   -fno-strict-aliasing -fno-common \
 		   -Werror-implicit-function-declaration \
 		   -Wno-format-security \
-		   -fno-delete-null-pointer-checks
+		   -fno-delete-null-pointer-checks \
+                -marm -march=armv7-a -mtune=cortex-a9 \
+                -mfpu=neon -mfloat-abi=hard \
+                -pipe
+
+                #-funswitch-loops -fpredictive-commoning \
+                #-fgcse-after-reload -fipa-cp-clone \
+                #-fmodulo-sched -fmodulo-sched-allow-regmoves \
+
 KBUILD_AFLAGS_KERNEL :=
 KBUILD_CFLAGS_KERNEL :=
 KBUILD_AFLAGS   := -D__ASSEMBLY__
diff -rupN kernel-s2-ics-update7/scripts/mkcompile_h kernel/scripts/mkcompile_h
--- kernel-s2-ics-update7/scripts/mkcompile_h	2012-07-23 16:37:38.000000000 +0800
+++ kernel/scripts/mkcompile_h	2012-07-27 21:37:57.000000000 +0800
@@ -73,8 +73,10 @@ UTS_TRUNCATE="cut -b -$UTS_LEN"
 
   echo \#define UTS_VERSION \"`echo $UTS_VERSION | $UTS_TRUNCATE`\"
 
-  echo \#define LINUX_COMPILE_BY \"`echo $LINUX_COMPILE_BY | $UTS_TRUNCATE`\"
-  echo \#define LINUX_COMPILE_HOST \"`echo $LINUX_COMPILE_HOST | $UTS_TRUNCATE`\"
+#  echo \#define LINUX_COMPILE_BY \"`echo $LINUX_COMPILE_BY | $UTS_TRUNCATE`\"
+#  echo \#define LINUX_COMPILE_HOST \"`echo $LINUX_COMPILE_HOST | $UTS_TRUNCATE`\"
+  echo \#define LINUX_COMPILE_BY \"Apolo\"
+  echo \#define LINUX_COMPILE_HOST \"byPedestre\"
 
   echo \#define LINUX_COMPILER \"`$CC -v 2>&1 | tail -n 1`\"
 ) > .tmpcompile
